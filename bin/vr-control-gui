#!/usr/bin/env python3
import os
import time
import json
import subprocess
import shlex
import re
import shutil
from pathlib import Path

import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk, Gdk, GLib

APP_VERSION = "v0.6.85-openxrfix9-close-steam-on-wivrn21"

STACK_SERVICE = "vr-stack-control.service"

CONFIG_DIR = Path(os.environ.get("XDG_CONFIG_HOME", Path.home()/".config")) / "vr-stack"
STACK_CONF = CONFIG_DIR / "stack.conf"
PROFILES_DIR = CONFIG_DIR / "profiles"
GUI_STATE = CONFIG_DIR / "gui_state.json"

DEFAULTS = {
    "tracking_name": "SlimeVR",
    "server_name": "WiVRn",
    "vr_name": "WayVR",
    # Prefer the launcher on PATH when installed via system package/AUR.
    # /opt/slimevr/slimevr is still used by some manual installs, but is not
    # universal.
    "tracking_cmd": "slimevr",
    "server_cmd": "wivrn-server",
    "vr_cmd": "wayvr",
    "tracking_ready": "slimevr\\.jar",
    "server_pgrep": "wivrn-server",
    "vr_pgrep": "(^|/)(wayvr)(\\s|$)",
    "profile": "default",
    "tracking_enabled": "true",
    "tracking_stop_when_disabled": "true",
    # Prefer a stable per-user WiVRn runtime JSON with absolute library paths.
    # Some distros ship a Monado-style JSON with relative paths (../../../...) that breaks apps.
    "openxr_json": str(Path.home() / ".config" / "openxr" / "1" / "wivrn_runtime.json"),
    "xr_runtime": "wivrn",
    "steamvr_autostart": "false",
}


def ensure_dirs():
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    PROFILES_DIR.mkdir(parents=True, exist_ok=True)


def read_kv(path: Path):
    """Read a very small KEY=VALUE config file.

    Values may be plain (no spaces/specials) or quoted with single/double quotes.
    We strip surrounding quotes for convenience.
    """
    data = {}
    if not path.exists():
        return data
    for raw in path.read_text(errors="ignore").splitlines():
        line = raw.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        k, v = line.split("=", 1)
        k = k.strip()
        v = v.strip()
        # Strip surrounding quotes if present
        if len(v) >= 2 and ((v[0] == v[-1] == "'") or (v[0] == v[-1] == '"')):
            q = v[0]
            v = v[1:-1]
            if q == "'":
                pass
        data[k] = v
    return data





def _bash_single_quote(val: str) -> str:
    """Return a bash-safe single-quoted string."""
    # Escape for single quotes inside single quotes: 'foo'"'"'bar'
    return "'" + val.replace("'", "'\"'\"'") + "'"

def write_kv(path: Path, data: dict):
    """Write KEY=VALUE config as bash-safe assignments."""
    lines = []
    for k, v in data.items():
        if v is None:
            continue
        v = str(v)
        # Always quote to keep bash 'source' safe (regexes, pipes, spaces, etc.)
        lines.append(f"{k}={_bash_single_quote(v)}")
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text("\n".join(lines) + "\n")

def cfg_load():



    cfg = DEFAULTS.copy()
    raw = read_kv(STACK_CONF)
    # allow either snake_case or legacy keys
    mapping = {
        "tracking_name": ["tracking_name", "TRACKING_NAME"],
        "server_name": ["server_name", "SERVER_NAME"],
        "vr_name": ["vr_name", "VR_NAME"],
        "tracking_cmd": ["tracking_cmd", "TRACKING_CMD"],
        "server_cmd": ["server_cmd", "SERVER_CMD"],
        "vr_cmd": ["vr_cmd", "VR_CMD"],
        "tracking_ready": ["tracking_ready", "TRACKING_READY"],
        "server_pgrep": ["server_pgrep", "SERVER_PGREP"],
        "vr_pgrep": ["vr_pgrep", "VR_PGREP"],
        "profile": ["profile", "PROFILE"],
        "tracking_enabled": ["tracking_enabled", "TRACKING_ENABLED"],
        "tracking_stop_when_disabled": ["tracking_stop_when_disabled", "TRACK_STOP_WHEN_DISABLED", "TRACKING_STOP_WHEN_DISABLED"],
        "openxr_json": ["openxr_json", "OPENXR_JSON"],
        "xr_runtime": ["xr_runtime", "XR_RUNTIME"],
    }
    for key, aliases in mapping.items():
        for a in aliases:
            if a in raw and raw[a] != "":
                cfg[key] = raw[a]
                break
    return cfg


def cfg_save(cfg: dict):
    # write using lower-case keys
    write_kv(STACK_CONF, cfg)


def _cmd_path_exists(cmd: str) -> bool:
    """Return True if cmd looks like a path and exists."""
    c = (cmd or "").strip()
    if not c:
        return False
    # If it's a full shell command, only consider the first token for path checks.
    try:
        tok = shlex.split(c)[0]
    except Exception:
        tok = c.split(" ", 1)[0]
    if tok.startswith("/"):
        return os.path.exists(tok)
    return False



def _normalize_name_candidates(name: str) -> list[str]:
    n = (name or "").strip()
    if not n:
        return []
    lower = n.lower()
    # Generate a small set of stable candidates
    cands = []
    cands.append(n)
    cands.append(lower)
    cands.append(lower.replace(" ", ""))
    cands.append(lower.replace(" ", "-"))
    cands.append(lower.replace(" ", "_"))
    # Also try to split CamelCase into lowercase without spaces: SlimeVR -> slimevr
    cands.append(re.sub(r"[^a-z0-9]+", "", lower))
    # De-dupe preserving order
    out = []
    for c in cands:
        c = c.strip()
        if c and c not in out:
            out.append(c)
    return out


_DESKTOP_FIELDS = {"name", "exec", "comment", "keywords"}

def _parse_desktop_file(path: Path) -> dict[str, str]:
    """Parse a .desktop file (minimally) and return lowercased keys."""
    data = {}
    try:
        for raw in path.read_text(errors="ignore").splitlines():
            line = raw.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            k, v = line.split("=", 1)
            k = k.strip().lower()
            if k in _DESKTOP_FIELDS:
                data[k] = v.strip()
    except Exception:
        return {}
    return data


def _clean_desktop_exec(exec_line: str) -> str:
    """Remove .desktop field codes like %u, %f, %F, etc., keeping a runnable command."""
    if not exec_line:
        return ""
    try:
        toks = shlex.split(exec_line)
    except Exception:
        toks = exec_line.split()

    cleaned = []
    for t in toks:
        # Drop % codes entirely
        if t.startswith("%") and len(t) <= 3:
            continue
        # Drop tokens that contain standalone field codes
        if re.fullmatch(r"%[fFuUdDnNickvm]", t):
            continue
        cleaned.append(t)

    # Strip trailing field codes that sometimes appear glued
    s = " ".join(cleaned).strip()
    s = re.sub(r"\s%[fFuUdDnNickvm]\b", "", s).strip()
    return s


def _detect_from_desktop(app_name: str) -> str:
    """Find best matching Exec= from .desktop entries for app_name."""
    name = (app_name or "").strip().lower()
    if not name:
        return ""

    desktop_dirs = [
        Path.home() / ".local" / "share" / "applications",
        Path("/usr/share/applications"),
    ]

    best = ("", -1)  # (exec, score)

    for d in desktop_dirs:
        if not d.exists():
            continue
        for p in d.glob("*.desktop"):
            data = _parse_desktop_file(p)
            if not data:
                continue
            dn = (data.get("name") or "").strip().lower()
            de = (data.get("exec") or "").strip()
            if not de:
                continue
            dl = de.lower()

            score = -1
            # Prefer Name matches over Exec matches
            if dn == name:
                score = 100
            elif name and dn and name in dn:
                score = 80
            elif name and dl and name in dl:
                score = 60

            # Bonus if desktop Name contains one of our normalized candidates
            for c in _normalize_name_candidates(app_name):
                cl = c.lower()
                if cl and dn and cl == dn:
                    score = max(score, 95)
                elif cl and dn and cl in dn:
                    score = max(score, 85)
                elif cl and dl and cl in dl:
                    score = max(score, 65)

            if score > best[1]:
                best = (de, score)

    return _clean_desktop_exec(best[0]) if best[1] >= 0 else ""


def _detect_from_running_process(app_name: str) -> str:
    """Try to detect a stable command from a running process; ignore AppImage temp mounts."""
    name = (app_name or "").strip()
    if not name:
        return ""
    # pgrep uses regex; escape input
    pat = re.escape(name)
    try:
        r = subprocess.run(["pgrep", "-af", pat], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True, timeout=2)
        out = (r.stdout or "").strip().splitlines()
    except Exception:
        out = []

    for line in out:
        # line format: "<pid> <cmd...>"
        parts = line.split(" ", 1)
        if len(parts) != 2:
            continue
        cmd = parts[1].strip()
        # Ignore ephemeral AppImage mounts/extracts
        if "/tmp/.mount_" in cmd or "/tmp/appimage_extracted_" in cmd:
            continue
        return cmd
    return ""


def detect_command_by_name(app_name: str, *, kind: str | None = None) -> str:
    """4-step detection: PATH -> .desktop -> hints -> running process."""
    n = (app_name or "").strip()
    if not n:
        return ""

    # 1) PATH executable match
    for cand in _normalize_name_candidates(n):
        p = shutil.which(cand)
        if p:
            return p

    # 2) Desktop entry match
    d = _detect_from_desktop(n)
    if d:
        return d

    # 3) Known hints (tiny whitelist)
    nl = n.lower()
    if kind == "tracking" or "slime" in nl:
        # SlimeVR stable locations
        if os.path.isfile("/usr/bin/slimevr"):
            return "/usr/bin/slimevr"
        if os.path.isfile("/opt/slimevr/slimevr"):
            return "/opt/slimevr/slimevr"
        if os.path.isfile("/usr/share/slimevr/slimevr.jar"):
            return "java -Xmx128M -jar /usr/share/slimevr/slimevr.jar run"
    if kind == "server" or "wivrn" in nl:
        p = shutil.which("wivrn-server")
        if p:
            return p
        return "wivrn-server"
    if kind == "vr" or "wayvr" in nl:
        p = shutil.which("wayvr")
        if p:
            return p
        return "wayvr"

    # 4) Running process
    r = _detect_from_running_process(n)
    if r:
        return r

    return ""


def detect_slimevr_cmd() -> str:
    return detect_command_by_name("SlimeVR", kind="tracking")


def detect_wivrn_cmd() -> str:
    return detect_command_by_name("WiVRn", kind="server")


def detect_wayvr_cmd() -> str:
    return detect_command_by_name("WayVR", kind="vr")


def state_load():
    if GUI_STATE.exists():
        try:
            return json.loads(GUI_STATE.read_text())
        except Exception:
            return {}
    return {}


def state_save(state: dict):
    GUI_STATE.write_text(json.dumps(state, indent=2, sort_keys=True))


def run_cmd(args, timeout=12):
    try:
        r = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, timeout=timeout)
        return r.returncode, (r.stdout or "").strip()
    except Exception as e:
        return 1, str(e)


def systemctl_user(*args):
    return run_cmd(["systemctl", "--user", *args])

def pgrep_first(pattern: str):
    # Return (pid, cmdline) for first matching process, or None.
    rc, out = run_cmd(["pgrep", "-af", pattern], timeout=2)
    if rc != 0:
        return None
    lines = [ln for ln in out.splitlines() if ln.strip()]
    if not lines:
        return None
    ln = lines[0]
    parts = ln.split(maxsplit=1)
    pid = parts[0]
    cmd = parts[1] if len(parts) > 1 else ""
    return pid, cmd



def pkill_pattern(pattern: str) -> int:
    try:
        r = subprocess.run(["pkill", "-f", pattern], capture_output=True, text=True)
        return r.returncode
    except FileNotFoundError:
        return 127


def pkill_pattern_sig(pattern: str, sig: str) -> int:
    """pkill -SIGNAL -f pattern"""
    try:
        r = subprocess.run(["pkill", f"-{sig}", "-f", pattern], capture_output=True, text=True)
        return r.returncode
    except FileNotFoundError:
        return 127



def _pgrep_any(patterns) -> bool:
    # Return True if any of the given pgrep -af regex patterns matches a running process.
    for pat in patterns:
        try:
            r = subprocess.run(["pgrep", "-af", pat], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            if r.returncode == 0:
                return True
        except Exception:
            pass
    return False


def _wait_gone(patterns, timeout_s: float = 3.0) -> bool:
    # Wait until none of the given patterns match running processes.
    end = time.time() + timeout_s
    while time.time() < end:
        if not _pgrep_any(patterns):
            return True
        time.sleep(0.2)
    return not _pgrep_any(patterns)



def _steam_running() -> bool:
    try:
        r = subprocess.run(["pgrep", "-x", "steam"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return r.returncode == 0
    except Exception:
        return False


def close_steam_for_wivrn(parent=None):
    '''Close Steam client when switching to WiVRn (best effort).'''
    steam_pats = [r"(^|/)(steam)(\\s|$)", r"steamwebhelper", r"steamservice", r"steamerrorreporter"]
    if not _pgrep_any(steam_pats):
        return

    # Ask Steam to shutdown cleanly (only if it's already running).
    try:
        if _steam_running() and shutil.which('steam'):
            subprocess.run(["steam", "-shutdown"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except Exception:
        pass

    # TERM then KILL.
    for pat in steam_pats:
        pkill_pattern_sig(pat, "TERM")
    _wait_gone(steam_pats, timeout_s=3.0)
    if _pgrep_any(steam_pats):
        for pat in steam_pats:
            pkill_pattern_sig(pat, "KILL")
        _wait_gone(steam_pats, timeout_s=2.0)

def stop_stack_components(cfg: dict) -> None:
    # Stop in reverse order so dependencies unwind cleanly.
    vr_pat = cfg.get("vr_pgrep", r"(^|/)(wayvr)(\s|$)")
    srv_pat = cfg.get("server_pgrep", r"wivrn-server")
    trk_pat = cfg.get("tracking_ready", r"slimevr\.jar")

    for pat in (vr_pat, srv_pat, trk_pat):
        pkill_pattern(pat)

def open_in_editor(path: Path):
    editor = os.environ.get("EDITOR")
    if editor:
        subprocess.Popen([editor, str(path)])
        return
    # try common GUI editors, then fall back to xdg-open
    for cmd in ("gedit", "gnome-text-editor", "kate", "mousepad"):
        if shutil_which(cmd):
            subprocess.Popen([cmd, str(path)])
            return
    subprocess.Popen(["xdg-open", str(path)])


def shutil_which(cmd: str):
    for p in os.environ.get("PATH", "").split(os.pathsep):
        c = Path(p) / cmd
        if c.exists() and os.access(c, os.X_OK):
            return str(c)
    return None


def info_dialog(parent, title, body):
    d = Gtk.MessageDialog(parent, 0, Gtk.MessageType.INFO, Gtk.ButtonsType.OK, title)
    d.format_secondary_text(body)
    d.run()
    d.destroy()


def confirm_dialog(parent, title, body):
    d = Gtk.MessageDialog(parent, 0, Gtk.MessageType.QUESTION, Gtk.ButtonsType.OK_CANCEL, title)
    d.format_secondary_text(body)
    rc = d.run()
    d.destroy()
    return rc == Gtk.ResponseType.OK



# --- small UI helpers ---

def markup_escape(text: str) -> str:
    # Escape text for Pango markup.
    try:
        return GLib.markup_escape_text(text)
    except Exception:
        t = text or ""
        return t.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")



def apply_openxr_runtime(json_path: str) -> tuple[bool, str]:
    """Best-effort: set active OpenXR runtime.

    Important: some vendor manifests use a relative runtime.library_path. Copying such a JSON into
    ~/.config/openxr/1/active_runtime.json breaks it (the relative path becomes relative to ~/.config/...)
    and the runtime fails to load. We normalize to an absolute library_path when possible.
    """
    try:
        jp = Path(json_path).expanduser()
        if not jp.exists():
            return False, f"Missing runtime JSON: {json_path}"
        dst_dir = Path.home() / ".config" / "openxr" / "1"
        dst_dir.mkdir(parents=True, exist_ok=True)
        dst = dst_dir / "active_runtime.json"

        # Try to load + normalize library_path to absolute.
        try:
            import json
            data = json.loads(jp.read_text(encoding="utf-8", errors="ignore"))
            rt = data.get("runtime") or {}
            lib = rt.get("library_path")
            if isinstance(lib, str) and lib.strip():
                lib_s = lib.strip()
                lib_p = Path(lib_s)
                if not lib_p.is_absolute():
                    lib_p = (jp.parent / lib_s).resolve()
                    rt["library_path"] = str(lib_p)
                    data["runtime"] = rt
            dst.write_text(json.dumps(data, indent=2) + "\n", encoding="utf-8")
            return True, str(jp)
        except Exception:
            # Fallback: raw copy
            import shutil
            shutil.copy2(jp, dst)
            return True, str(jp)
    except Exception as e:
        return False, str(e)

def ensure_wivrn_openxr_json() -> str:
    """Return the best WiVRn OpenXR runtime JSON.

    Prefer the system-provided manifest (/usr/share/openxr/1/openxr_wivrn.json), because
    it matches what works when the user active_runtime.json is absent.

    If we can't find it, generate a minimal per-user manifest with an absolute library_path.
    """
    for cand in (
        Path('/usr/share/openxr/1/openxr_wivrn.json'),
        Path('/etc/openxr/1/openxr_wivrn.json'),
        Path('/usr/local/share/openxr/1/openxr_wivrn.json'),
    ):
        try:
            if cand.is_file():
                return str(cand)
        except Exception:
            pass

    dst_dir = Path.home() / '.config' / 'openxr' / '1'
    dst_dir.mkdir(parents=True, exist_ok=True)
    jp = dst_dir / 'wivrn_runtime.json'

    lib = None
    for lp in ('/usr/lib/wivrn/libopenxr_wivrn.so', '/usr/lib64/wivrn/libopenxr_wivrn.so'):
        try:
            if Path(lp).exists():
                lib = lp
                break
        except Exception:
            pass
    if not lib:
        lib = '/usr/lib/wivrn/libopenxr_wivrn.so'

    payload = {
        'file_format_version': '1.0.0',
        'runtime': {
            'name': 'WiVRn',
            'library_path': lib,
        },
    }

    try:
        import json
        jp.write_text(json.dumps(payload, indent=2) + "\n", encoding='utf-8')
    except Exception:
        pass

    return str(jp)


def steam_is_running() -> bool:
    try:
        r = subprocess.run(["pgrep", "-x", "steam"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return r.returncode == 0
    except Exception:
        return False


def relaunch_steam_with_openxr_import() -> tuple[bool, str]:
    """Restart Steam with PRESSURE_VESSEL_IMPORT_OPENXR_1_RUNTIMES=1 so Steam games see host OpenXR runtimes."""
    try:
        # Stop Steam cleanly
        subprocess.run(["pkill", "-x", "steam"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except Exception:
        pass
    # Wait a moment for it to exit
    end = time.time() + 3.0
    while time.time() < end:
        if not steam_is_running():
            break
        time.sleep(0.2)
    if steam_is_running():
        return False, "Steam is still running"
    try:
        env = os.environ.copy()
        env["PRESSURE_VESSEL_IMPORT_OPENXR_1_RUNTIMES"] = "1"
        # Force the OpenXR loader to use the host-selected runtime (helps in Proton/Pressure-Vessel)
        active = str(Path.home() / ".config" / "openxr" / "1" / "active_runtime.json")
        env["XR_RUNTIME_JSON"] = active
        env["OPENXR_RUNTIME_JSON"] = active
        # Some containers override XDG paths; make it explicit.
        env["XDG_CONFIG_HOME"] = str(Path.home() / ".config")
        subprocess.Popen(["steam"], env=env)
        return True, "Steam relaunched"
    except Exception as e:
        return False, str(e)

def detect_steamvr_openxr_json() -> str:
    candidates = [
        "/usr/share/openxr/1/openxr_steamvr.json",
        "/usr/share/openxr/1/openxr_steamvr_linux.json",
        "/usr/share/openxr/1/openxr_steamvr64.json",
        str(Path.home() / '.steam/steam/steamapps/common/SteamVR/steamxr_linux64.json'),
        str(Path.home() / '.local/share/Steam/steamapps/common/SteamVR/steamxr_linux64.json'),
    ]
    for p in candidates:
        try:
            if Path(p).exists():
                return p
        except Exception:
            pass
    return ""


def stop_xrizer() -> tuple[bool, str]:
    # Best-effort: stop XRizer processes so SteamVR can run cleanly.
    # We only kill user processes; no sudo required.
    try:
        r = subprocess.run(['pkill','-f','/opt/xrizer'], capture_output=True, text=True)
        if r.returncode == 0:
            return True, 'XRizer stopped'
        # rc=1 means no processes matched
        return True, 'XRizer not running'
    except FileNotFoundError:
        return False, 'pkill not found'
    except Exception as e:
        return False, str(e)

# --- OpenVR runtime switching (SteamVR <-> XRizer) ---

def detect_steamvr_root() -> str | None:
    candidates = [
        os.path.expanduser("~/.steam/steam/steamapps/common/SteamVR"),
        os.path.expanduser("~/.local/share/Steam/steamapps/common/SteamVR"),
    ]
    for c in candidates:
        if os.path.isdir(c):
            return c
    return None

def detect_vrpathreg() -> str | None:
    # vrpathreg ships with SteamVR
    roots = [detect_steamvr_root()]
    roots = [r for r in roots if r]
    for root in roots:
        cand = os.path.join(root, "bin", "linux64", "vrpathreg")
        if os.path.isfile(cand) and os.access(cand, os.X_OK):
            return cand
    # fallback if it's already in PATH
    return shutil.which("vrpathreg")

def set_openvr_runtime(runtime_dir: str) -> tuple[bool, str]:
    vrpathreg = detect_vrpathreg()
    if not vrpathreg:
        return False, "vrpathreg not found (SteamVR not installed?)"

    try:
        r = subprocess.run([vrpathreg, "setruntime", runtime_dir], capture_output=True, text=True)
        ok = (r.returncode == 0)
        out = (r.stdout or "").strip()
        err = (r.stderr or "").strip()
        blob = "\n".join([x for x in [out, err] if x])
        if ok:
            return True, f"OpenVR runtime set to: {runtime_dir}"
        return False, f"Failed to set OpenVR runtime: {blob or 'unknown error'}"
    except Exception as e:
        return False, f"Failed to set OpenVR runtime: {e}"

def ensure_openvr_xrizer_enabled() -> tuple[bool, str]:
    if os.path.isdir("/opt/xrizer"):
        return set_openvr_runtime("/opt/xrizer")
    return False, "XRizer not installed (/opt/xrizer missing)"

def ensure_openvr_steamvr_enabled() -> tuple[bool, str]:
    root = detect_steamvr_root()
    if root:
        return set_openvr_runtime(root)
    return False, "SteamVR runtime folder not found"

def cmd_display_name(cmd: str, fallback: str) -> str:
    # Friendly name for a command: basename of first token.
    cmd = (cmd or "").strip()
    if not cmd:
        return fallback
    try:
        parts = shlex.split(cmd)
    except Exception:
        parts = cmd.split()
    if not parts:
        return fallback
    exe = (parts[0] or "").strip()
    base = os.path.basename(exe)
    return base or fallback

class VRControlApp(Gtk.Window):
    def __init__(self):
        super().__init__(title=f"VR Stack Control {APP_VERSION}")
        ensure_dirs()

        self.cfg = cfg_load()
        self.state = state_load()

        # Auto-fill common commands when the saved value is missing or points to a
        # non-existent legacy location (e.g. /opt/slimevr/slimevr on systems where
        # SlimeVR is installed to /usr/bin/slimevr + /usr/share/slimevr/slimevr.jar).
        self._autofill_launch_commands()

        self.set_default_size(920, 560)
        self.set_border_width(10)

        root = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        self.add(root)

        self.stack = Gtk.Stack()
        self.stack.set_transition_type(Gtk.StackTransitionType.SLIDE_LEFT_RIGHT)
        self.stack.set_transition_duration(180)

        sidebar = Gtk.StackSidebar()
        sidebar.set_stack(self.stack)
        sidebar.set_size_request(200, -1)

        # Left: sidebar (tabs). Right: quick controls + page content.
        root.pack_start(sidebar, False, False, 0)

        right = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        right.set_hexpand(True)
        right.set_vexpand(True)
        root.pack_start(right, True, True, 0)

        self.quickbar = self.build_quick_controls()
        right.pack_start(self.quickbar, False, False, 0)
        right.pack_start(self.stack, True, True, 0)

        self.status_view = self.build_status_view()
        self.apps_view = self.build_apps_view()
        self.profiles_view = self.build_profiles_view()
        self.debug_view = self.build_debug_view()

        self.stack.add_titled(self.status_view, "status", "Status")
        self.stack.add_titled(self.apps_view, "apps", "Apps & Settings")
        self.stack.add_titled(self.profiles_view, "profiles", "Profiles")
        self.stack.add_titled(self.debug_view, "debug", "Debug")

        # Live status: keep it fresh automatically so the running-app list
        # and indicator lights update without needing manual clicks.
        self._alive = True
        self.connect("destroy", self.on_destroy)
        self.refresh_status()

        # GUI-scoped autostart: if enabled, start the stack when this window opens.
        try:
            if bool(self.state.get('autostart_on_open', False)):
                systemctl_user('start', STACK_SERVICE)
        except Exception:
            pass
        GLib.timeout_add_seconds(2, self._auto_refresh)

        self.show_all()

        # Update labels that depend on the current command names.
        self.update_display_names()


    def update_display_names(self) -> None:
        """Update UI labels to reflect the configured command names."""
        try:
            self.name_tracking = (self.cfg.get("tracking_name") or "").strip() or cmd_display_name(self.cfg.get("tracking_cmd", ""), "Tracking")
            self.name_server = (self.cfg.get("server_name") or "").strip() or cmd_display_name(self.cfg.get("server_cmd", ""), "Server")
            self.name_vr = (self.cfg.get("vr_name") or "").strip() or cmd_display_name(self.cfg.get("vr_cmd", ""), "VR App")

            if getattr(self, "lbl_tracking_name", None) is not None:
                self.lbl_tracking_name.set_text(f"Tracking ({self.name_tracking})")
            if getattr(self, "lbl_server_name", None) is not None:
                self.lbl_server_name.set_text(f"Server ({self.name_server})")
            if getattr(self, "lbl_vr_name", None) is not None:
                self.lbl_vr_name.set_text(f"VR App ({self.name_vr})")

            if getattr(self, "lbl_order_note", None) is not None:
                self.lbl_order_note.set_text(
                    f"Expected order: Tracking ‚Üí Server ‚Üí VR App  ( {self.name_tracking} ‚Üí {self.name_server} ‚Üí {self.name_vr} )"
                )
        except Exception:
            # Never crash the app because labels are missing.
            pass

    def _autofill_launch_commands(self) -> None:
        """Auto-detect launch commands and update config when current values are stale.

        This keeps the UI sane across different install styles (AUR/system packages vs /opt installs)
        and avoids storing transient AppImage /tmp/.mount_* paths.
        """
        changed = False

        def _should_replace(key: str, cur: str, det: str) -> bool:
            cur = (cur or "").strip()
            det = (det or "").strip()
            if not det:
                return False
            if not cur:
                return True
            # Replace legacy defaults when detected differs.
            if key == "tracking_cmd" and cur == "/opt/slimevr/slimevr" and det != cur:
                return True
            # Replace if it looks like a path that doesn't exist.
            if _cmd_path_exists(cur) is False and cur.startswith("/"):
                return True
            return False

        # Tracking
        det_track = detect_slimevr_cmd()
        if _should_replace("tracking_cmd", self.cfg.get("tracking_cmd", ""), det_track):
            self.cfg["tracking_cmd"] = det_track
            changed = True

        # Server
        det_server = detect_wivrn_cmd()
        if _should_replace("server_cmd", self.cfg.get("server_cmd", ""), det_server):
            self.cfg["server_cmd"] = det_server
            changed = True

        # VR app
        det_vr = detect_wayvr_cmd()
        if _should_replace("vr_cmd", self.cfg.get("vr_cmd", ""), det_vr):
            self.cfg["vr_cmd"] = det_vr
            changed = True

        if changed:
            try:
                cfg_save(self.cfg)
            except Exception:
                pass

    def on_destroy(self, *_args):
        self._alive = False

    def _auto_refresh(self):
        """Periodic UI refresh (runs on the GTK main loop)."""
        if not getattr(self, "_alive", False):
            return False
        try:
            self.refresh_status()
        except Exception:
            # Never crash the whole app because a refresh query failed.
            pass
        return True






    def toast(self, msg: str, seconds: int = 4):
        """Lightweight status message without popups.

        We temporarily append the message to the window title, then restore.
        """
        try:
            base = f"VR Stack Control {APP_VERSION}"
            self.set_title(f"{base} ‚Äî {msg}")

            def _restore():
                try:
                    self.set_title(base)
                except Exception:
                    pass
                return False

            GLib.timeout_add_seconds(max(1, int(seconds)), _restore)
        except Exception:
            pass

    # ---------------------------------------------------------------------
    # Logging / helpers (best-effort; never crash the GUI)
    # ---------------------------------------------------------------------
    def debug_log(self, msg: str):
        try:
            if hasattr(self, "debug_buffer") and self.debug_buffer is not None:
                end = self.debug_buffer.get_end_iter()
                self.debug_buffer.insert(end, msg + "\n")
            else:
                print(msg)
        except Exception:
            try:
                print(msg)
            except Exception:
                pass

    def find_steamvr_openxr_json(self) -> str:
        """Locate SteamVR's OpenXR runtime JSON (steamxr_linux64.json)."""
        candidates = []
        home = os.path.expanduser("~")
        candidates += [
            os.path.join(home, ".steam/steam/steamapps/common/SteamVR/steamxr_linux64.json"),
            os.path.join(home, ".local/share/Steam/steamapps/common/SteamVR/steamxr_linux64.json"),
            os.path.join(home, ".steam/root/steamapps/common/SteamVR/steamxr_linux64.json"),
        ]

        vdf_paths = [
            os.path.join(home, ".steam/steam/steamapps/libraryfolders.vdf"),
            os.path.join(home, ".local/share/Steam/steamapps/libraryfolders.vdf"),
            os.path.join(home, ".steam/root/steamapps/libraryfolders.vdf"),
        ]
        for vdf in vdf_paths:
            try:
                if not os.path.exists(vdf):
                    continue
                data = open(vdf, "r", errors="ignore").read()
                for p in re.findall(r'"path"\s+"([^"]+)"', data):
                    p = p.replace('\\\\', '\\')
                    candidates.append(os.path.join(p, "steamapps/common/SteamVR/steamxr_linux64.json"))
                for p in re.findall(r'"\\d+"\s+"([^"]+)"', data):
                    if "/" in p or "\\\\" in p:
                        p = p.replace('\\\\', '\\')
                        candidates.append(os.path.join(p, "steamapps/common/SteamVR/steamxr_linux64.json"))
            except Exception:
                pass

        for c in candidates:
            try:
                if c and os.path.isfile(c):
                    return c
            except Exception:
                pass
        return ""



    def update_detected_paths(self):
        """Update detected path fields + status badges."""
        try:
            # Active OpenXR runtime (resolved symlink/target)
            active = Path("~/.config/openxr/1/active_runtime.json").expanduser()
            active_txt = str(active.resolve()) if active.exists() else ""

            # WiVRn OpenXR JSON (system)
            wivrn_json = Path("/usr/share/openxr/1/openxr_wivrn.json")
            wivrn_txt = str(wivrn_json) if wivrn_json.exists() else ""

            # SteamVR OpenXR JSON (auto-detect + override)
            steamvr_openxr = self.cfg.get("override_steamvr_openxr_json") or self.find_steamvr_openxr_json()
            steamvr_openxr_txt = steamvr_openxr or ""

            # SteamVR root (derive from SteamVR OpenXR json if possible + override)
            steamvr_root = self.cfg.get("override_steamvr_root")
            if not steamvr_root and steamvr_openxr_txt:
                try:
                    steamvr_root = str(Path(steamvr_openxr_txt).expanduser().parent)
                except Exception:
                    steamvr_root = ""
            steamvr_root_txt = steamvr_root or ""

            # XRizer root (override or /opt/xrizer if present)
            xrizer_root = self.cfg.get("override_xrizer_root") or ("/opt/xrizer" if Path("/opt/xrizer").is_dir() else "")
            xrizer_txt = xrizer_root or ""

            # openvrpaths.vrpath (canonical + common Steam locations + override)
            openvrpaths = self.cfg.get("override_openvrpaths")
            if not openvrpaths:
                # Ensure canonical openvrpaths exists and ~/.config/openvr points to it
                try:
                    home = Path.home()
                    canonical = home / ".local" / "share" / "openvr" / "openvrpaths.vrpath"
                    legacy = home / ".config" / "openvr" / "openvrpaths.vrpath"
                    canonical.parent.mkdir(parents=True, exist_ok=True)
                    legacy.parent.mkdir(parents=True, exist_ok=True)

                    # If legacy exists as a real file and canonical is missing, copy legacy into canonical
                    if (not canonical.exists()) and legacy.exists() and legacy.is_file() and (not legacy.is_symlink()):
                        try:
                            canonical.write_bytes(legacy.read_bytes())
                        except Exception:
                            import shutil as _sh
                            _sh.copy2(str(legacy), str(canonical))

                    # If canonical exists, ensure legacy becomes a symlink to canonical (back up any real file first)
                    if canonical.exists():
                        if legacy.exists() and (not legacy.is_symlink()):
                            ts = time.strftime("%Y%m%d-%H%M%S")
                            try:
                                legacy.rename(legacy.with_suffix(legacy.suffix + f".bak.{ts}"))
                            except Exception:
                                pass
                        try:
                            if legacy.is_symlink() or legacy.exists():
                                legacy.unlink()
                        except Exception:
                            pass
                        try:
                            legacy.symlink_to(canonical)
                        except Exception:
                            pass
                except Exception:
                    pass

                candidates = [
                    Path("~/.local/share/openvr/openvrpaths.vrpath").expanduser(),
                    Path("~/.config/openvr/openvrpaths.vrpath").expanduser(),
                    Path("~/.local/share/Steam/config/openvrpaths.vrpath").expanduser(),
                    Path("~/.steam/steam/config/openvrpaths.vrpath").expanduser(),
                    Path("~/.steam/root/config/openvrpaths.vrpath").expanduser(),
                ]
                # Prefer real files first
                for c in candidates:
                    if c.is_file():
                        openvrpaths = str(c)
                        break
                # If we only have a symlink (even dangling), show it so the user can repair it
                if not openvrpaths:
                    for c in candidates:
                        if c.is_symlink():
                            openvrpaths = str(c)
                            break
            openvrpaths_txt = openvrpaths or ""

            # Write entries
            self.entry_path_openxr_active.set_text(active_txt)
            self.entry_path_openxr_wivrn.set_text(wivrn_txt)
            self.entry_path_openxr_steamvr.set_text(steamvr_openxr_txt)
            self.entry_path_steamvr_root.set_text(steamvr_root_txt)
            self.entry_path_xrizer.set_text(xrizer_txt)
            self.entry_path_openvrpaths.set_text(openvrpaths_txt)

            # Status badges (‚úî / ‚ö† / ‚ùå)
            self.lbl_path_openxr_active.set_text(self._status_for_path(active_txt, "file"))
            self.lbl_path_openxr_wivrn.set_text(self._status_for_path(wivrn_txt, "file"))
            self.lbl_path_openxr_steamvr.set_text(self._status_for_path(steamvr_openxr_txt, "file"))
            self.lbl_path_steamvr_root.set_text(self._status_for_path(steamvr_root_txt, "dir"))
            self.lbl_path_xrizer.set_text(self._status_for_path(xrizer_txt, "dir"))
            self.lbl_path_openvrpaths.set_text(self._status_for_path(openvrpaths_txt, "file"))

        except Exception as e:
            self.debug_log("update_detected_paths failed: " + repr(e))
    def build_quick_controls(self):
        _toggle = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        _toggle.set_margin_bottom(4)

        title = Gtk.Label(xalign=0)
        title.set_markup("<b>Stack control</b>")
        _toggle.pack_start(title, False, False, 0)

        self.lbl_quick_state = Gtk.Label(xalign=0)
        self.lbl_quick_state.set_text("üî¥ Stopped")
        _toggle.pack_start(self.lbl_quick_state, False, False, 0)

        _toggle.pack_start(Gtk.Separator(orientation=Gtk.Orientation.VERTICAL), False, False, 6)

        self.btn_quick_start = Gtk.Button(label="Start")
        self.btn_quick_stop = Gtk.Button(label="Stop")
        self.btn_quick_start.connect("clicked", lambda *_: self.on_quick_start())
        self.btn_quick_stop.connect("clicked", lambda *_: self.on_quick_stop())
        _toggle.pack_start(self.btn_quick_start, False, False, 0)
        _toggle.pack_start(self.btn_quick_stop, False, False, 0)

        self.btn_quick_autostart = Gtk.ToggleButton(label="Autostart")
        self.btn_quick_autostart.set_tooltip_text("Start VR stack automatically when this control panel opens (not on boot)")
        self.btn_quick_autostart.connect("toggled", lambda *_: self.on_quick_autostart_toggled())
        _toggle.pack_start(self.btn_quick_autostart, False, False, 0)


        _toggle.pack_start(Gtk.Separator(orientation=Gtk.Orientation.VERTICAL), False, False, 6)

        rt_lbl = Gtk.Label(xalign=0)
        rt_lbl.set_markup("<b>XR Runtime</b>")
        _toggle.pack_start(rt_lbl, False, False, 0)

        self.combo_runtime = Gtk.ComboBoxText()
        self.combo_runtime.append("wivrn", "WiVRn (Native / Quest streaming)")
        self.combo_runtime.append("steamvr", "SteamVR (Steam Link / Legacy)")
        _toggle.pack_start(self.combo_runtime, False, False, 0)

        # SteamVR autostart toggle (only relevant when XR Runtime=SteamVR).
        self.chk_steamvr_autostart = Gtk.CheckButton(label="Auto-start SteamVR")
        self.chk_steamvr_autostart.set_tooltip_text(
            "If enabled, starting the stack in SteamVR mode will launch SteamVR automatically.\n"
            "Recommended OFF to prevent SteamVR opening unexpectedly when switching runtimes."
        )
        try:
            self.chk_steamvr_autostart.set_active(is_true(self.cfg.get("steamvr_autostart", "false")))
        except Exception:
            pass
        self.chk_steamvr_autostart.connect("toggled", lambda *_: self.on_steamvr_autostart_toggled())
        _toggle.pack_start(self.chk_steamvr_autostart, False, False, 8)

        cur = (self.cfg.get("xr_runtime", "wivrn") or "wivrn").strip().lower()
        # If config was edited manually, infer from openxr_json too
        oj = (self.cfg.get("openxr_json") or "").lower()
        if "steamvr" in oj:
            cur = "steamvr"
        if cur not in ("wivrn", "steamvr"):
            cur = "wivrn"
        self.combo_runtime.set_active_id(cur)
        self.combo_runtime.connect("changed", lambda *_: self.on_runtime_changed())

        # Enable only when SteamVR is selected
        self.chk_steamvr_autostart.set_sensitive(cur == "steamvr")

        # Beginner-friendly hint
        hint = Gtk.Label(xalign=0)
        hint.set_line_wrap(True)
        hint.set_max_width_chars(70)
        hint.set_markup(
            "<span size='small' foreground='#777'>"
            "Starts/stops the VR stack in order: Tracking ‚Üí Server ‚Üí VR App (systemd --user)."
            "</span>"
        )

        wrap = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        wrap.pack_start(_toggle, False, False, 0)
        wrap.pack_start(hint, False, False, 0)
        return wrap

    def update_quick_controls(self, svc_active: bool):
        if svc_active:
            self.lbl_quick_state.set_text("üü¢ Running")
            self.btn_quick_start.set_sensitive(False)
            self.btn_quick_stop.set_sensitive(True)
        else:
            self.lbl_quick_state.set_text("üî¥ Stopped")
            self.btn_quick_start.set_sensitive(True)
            self.btn_quick_stop.set_sensitive(False)

    def on_quick_start(self):
        # Ensure OpenXR runtime matches config
        try:
            oj = (self.cfg.get("openxr_json") or "").strip()
            if oj:
                apply_openxr_runtime(oj)
        except Exception:
            pass

        # systemctl_user() returns (rc:int, combined_output:str)
        rc, out = systemctl_user("start", STACK_SERVICE)
        if rc == 0:
            self.toast("Starting‚Ä¶")
        else:
            # systemd sends errors on stderr, but we capture combined output.
            msg = out.strip() or "unknown error"
            self.toast(f"Start failed: {msg}")
        self.refresh_status()

    def on_quick_stop(self):
        # Stop should always stop the actual processes, even if the systemd unit is oneshot.
        rc, out = systemctl_user("stop", STACK_SERVICE)
        stop_stack_components(self.cfg)

        if rc == 0:
            self.toast("Stopping‚Ä¶")
        else:
            msg = out.strip() or "unknown error"
            self.toast(f"Stop requested (systemd said: {msg}).")
        self.refresh_status()

    def on_quick_autostart_toggled(self):
        # Avoid recursion when refresh_status updates the toggle.
        if getattr(self, '_updating_autostart', False):
            return
        enable = bool(self.btn_quick_autostart.get_active())
        # GUI-scoped autostart: we do NOT systemctl enable/disable.
        self.state['autostart_on_open'] = enable
        state_save(self.state)
        if enable:
            # Start immediately on toggle-on (best effort).
            rc, out = systemctl_user('start', STACK_SERVICE)
            self.toast('Autostart on open enabled (starting now)‚Ä¶' if rc == 0 else f'Start failed: {out}')
        else:
            self.toast('Autostart on open disabled')
        self.refresh_status()

    def on_steamvr_autostart_toggled(self):
        """Persist the SteamVR auto-launch preference used by the stack script."""
        try:
            enabled = bool(self.chk_steamvr_autostart.get_active())
        except Exception:
            enabled = False
        self.cfg["steamvr_autostart"] = "true" if enabled else "false"
        self.save_cfg()
        self.refresh_status()


    def on_runtime_changed(self):
        # Remember previous selection so we can run safe post-switch helpers.
        prev_runtime = (self.cfg.get("xr_runtime", "wivrn") or "wivrn").strip().lower()
        try:
            choice = self.combo_runtime.get_active_id() or "wivrn"
        except Exception:
            choice = "wivrn"
        choice = (choice or "wivrn").strip().lower()

        # Enable/disable SteamVR autostart toggle based on selection
        try:
            self.chk_steamvr_autostart.set_sensitive(choice == "steamvr")
        except Exception:
            pass


        # Mode switch safety: ensure only one compositor stack is running.
        start_stack_after = False
        launch_steamvr_after = False

        if choice == "steamvr":
            # Stop WiVRn stack service and kill leftovers so SteamVR can start cleanly.
            systemctl_user("stop", STACK_SERVICE)
            stop_stack_components(self.cfg)
            pkill_pattern(r"wivrn-server")
            pkill_pattern(r"(^|/)(wayvr)(\s|$)")
        else:
            # Stop SteamVR/OpenVR compositor processes before starting WiVRn mode.
            # Ask before closing SteamVR, since this will end any running SteamVR session.
            steamvr_pats = [r"vrserver", r"vrcompositor", r"vrmonitor", r"vrwebhelper", r"steamvr", r"SteamVR"]
            if _pgrep_any(steamvr_pats):
                dlg = Gtk.MessageDialog(
                    transient_for=self,
                    modal=True,
                    message_type=Gtk.MessageType.WARNING,
                    buttons=Gtk.ButtonsType.NONE,
                    text="Switch to WiVRn?",
                )
                dlg.format_secondary_text("SteamVR is currently running. To switch to WiVRn, SteamVR must be closed.\n\nClose SteamVR now?")
                dlg.add_buttons(
                    "Cancel", Gtk.ResponseType.CANCEL,
                    "Close SteamVR", Gtk.ResponseType.OK,
                )
                resp = dlg.run()
                dlg.destroy()
                if resp != Gtk.ResponseType.OK:
                    try:
                        self.combo_runtime.set_active_id("steamvr")
                    except Exception:
                        pass
                    return
                
                # Force-stop SteamVR and wait until it is actually gone to avoid mixed-mode.
                # First try TERM, then escalate to KILL if needed.
                pkill_pattern_sig(r"vrcompositor", "TERM")
                pkill_pattern_sig(r"vrserver", "TERM")
                pkill_pattern_sig(r"vrmonitor", "TERM")
                pkill_pattern_sig(r"vrwebhelper", "TERM")
                pkill_pattern_sig(r"steamvr", "TERM")
                _wait_gone(steamvr_pats, timeout_s=2.0)

                if _pgrep_any(steamvr_pats):
                    pkill_pattern_sig(r"vrcompositor", "KILL")
                    pkill_pattern_sig(r"vrserver", "KILL")
                    pkill_pattern_sig(r"vrmonitor", "KILL")
                    pkill_pattern_sig(r"vrwebhelper", "KILL")
                    pkill_pattern_sig(r"steamvr", "KILL")
                    _wait_gone(steamvr_pats, timeout_s=2.0)

                if _pgrep_any(steamvr_pats):
                    info_dialog(self, "SteamVR still running", "SteamVR could not be closed automatically. Please close SteamVR and try again.")
                    try:
                        self.combo_runtime.set_active_id("steamvr")
                    except Exception:
                        pass
                    return

            # WiVRn selection: also close Steam client so it doesn't pop open.
            close_steam_for_wivrn(self)

        if choice == "steamvr":
            steam_json = (self.cfg.get("override_steamvr_openxr_json") or "").strip() or detect_steamvr_openxr_json()
            if not steam_json:
                self.toast("SteamVR OpenXR runtime JSON not found. Install SteamVR first.")
                try:
                    self.combo_runtime.set_active_id("wivrn")
                except Exception:
                    pass
                return
            self.cfg["xr_runtime"] = "steamvr"
            self.cfg["openxr_json"] = steam_json
            ok, msg = apply_openxr_runtime(steam_json)
            # Stop XRizer if present (it can hijack SteamVR startup)
            sx_ok, sx_msg = stop_xrizer()
            ov_ok, ov_msg = ensure_openvr_steamvr_enabled()
            if ok:
                self.toast(f"OpenXR runtime set to SteamVR. {sx_msg} (OpenVR: {ov_msg})")
            # Optional convenience: launch SteamVR after saving config.
            # Controlled by the "Auto-start SteamVR" checkbox.
            try:
                launch_steamvr_after = bool(self.chk_steamvr_autostart.get_active())
            except Exception:
                launch_steamvr_after = False

            # Persist the checkbox as config so the systemd unit can also use it.
            self.cfg["steamvr_autostart"] = "true" if launch_steamvr_after else "false"
        else:
            wivrn_json = ensure_wivrn_openxr_json()
            self.cfg["xr_runtime"] = "wivrn"
            self.cfg["openxr_json"] = wivrn_json
            ok, msg = apply_openxr_runtime(wivrn_json)
            ov_ok, ov_msg = ensure_openvr_xrizer_enabled()
            if ok:
                self.toast(f"OpenXR runtime set to WiVRn (OpenVR: {ov_msg})")
                # Steam games launched under the Steam container may ignore host active_runtime.json unless Steam
                # Steam/Proton VR games may require PRESSURE_VESSEL_IMPORT_OPENXR_1_RUNTIMES=1 in game launch options.
                # We intentionally do NOT restart or launch Steam when switching to WiVRn.
                # Start the stack after saving config, so the service reads the new XR_RUNTIME/openxr_json.
                start_stack_after = False  # do not auto-start stack when switching runtime

                # Safety net: if SteamVR pops back up (some setups auto-restart it), force-close it again.
                steamvr_pats = [r"vrserver", r"vrcompositor", r"vrmonitor", r"vrwebhelper", r"steamvr", r"SteamVR"]
                time.sleep(0.5)
                if _pgrep_any(steamvr_pats):
                    pkill_pattern_sig(r"vrcompositor", "TERM")
                    pkill_pattern_sig(r"vrserver", "TERM")
                    _wait_gone(steamvr_pats, timeout_s=2.0)
                    if _pgrep_any(steamvr_pats):
                        pkill_pattern_sig(r"vrcompositor", "KILL")
                        pkill_pattern_sig(r"vrserver", "KILL")
                        _wait_gone(steamvr_pats, timeout_s=2.0)
                    if _pgrep_any(steamvr_pats):
                        self.toast("SteamVR is still running (may block WiVRn)")
            else:
                self.toast(f"Failed to set WiVRn runtime: {msg}")
                return
        # Save config BEFORE starting anything that reads it (systemd unit / SteamVR),
        # otherwise we can regress into mixed-mode (SteamVR launches while switching to WiVRn).
        try:
            cfg_save(self.cfg)
        except Exception as e:
            self.toast(f"Failed to save config: {e}")
            return

        # When switching back from SteamVR -> WiVRn, Steam can leave OpenVR pointing at the
        # wrong openvrpaths.vrpath. Auto-repair it so SteamVR/XR runtime switching is seamless.
        # Keep the manual button as well for troubleshooting.
        try:
            if prev_runtime == "steamvr" and choice == "wivrn":
                self.repair_openvrpaths()
        except Exception:
            pass

        # Actions that may read config / affect compositor state.
        try:
            if start_stack_after:
                systemctl_user("start", STACK_SERVICE)
            if launch_steamvr_after:
                if not _pgrep_any([r"vrserver", r"vrcompositor", r"steamvr", r"SteamVR"]):
                    subprocess.Popen(["steam", "steam://rungameid/250820"])
        except Exception:
            pass

        # Reload from disk to ensure the selection sticks
        try:
            self.cfg = cfg_load()
            cur = (self.cfg.get('xr_runtime', 'wivrn') or 'wivrn').strip().lower()
            if cur not in ('wivrn','steamvr'):
                cur = 'wivrn'
            # keep UI consistent
            self.combo_runtime.set_active_id(cur)
        except Exception:
            pass


    # ---------------- Status ----------------
    def build_status_view(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)

        header = self.section_header("Live status")
        box.pack_start(header, False, False, 0)

        grid = Gtk.Grid(column_spacing=10, row_spacing=8)
        box.pack_start(grid, False, False, 0)

        self.lbl_service = Gtk.Label(xalign=0)
        self.lbl_autostart = Gtk.Label(xalign=0)
        self.lbl_profile = Gtk.Label(xalign=0)

        self._grid_row(grid, 0, "Stack service:", self.lbl_service)
        self._grid_row(grid, 1, "Start on app open:", self.lbl_autostart)
        self._grid_row(grid, 2, "Active profile:", self.lbl_profile)

        btn_row = Gtk.Box(spacing=10)
        box.pack_start(btn_row, False, False, 0)

        btn_refresh = Gtk.Button(label="Refresh")
        btn_refresh.set_image(Gtk.Image.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON))
        btn_refresh.set_always_show_image(True)
        btn_refresh.connect("clicked", lambda *_: self.refresh_status())

        btn_row.pack_start(btn_refresh, False, False, 0)

        # Stack processes (live)
        proc_header = self.section_header("Running apps (detected)")
        box.pack_start(proc_header, False, False, 0)

        proc_grid = Gtk.Grid(column_spacing=12, row_spacing=8)
        proc_grid.set_hexpand(True)

        # column headers
        h1 = self.small_muted("Component")
        h2 = self.small_muted("Expected order")
        h3 = self.small_muted("Detected right now")
        proc_grid.attach(h1, 0, 0, 1, 1)
        proc_grid.attach(h2, 1, 0, 1, 1)
        proc_grid.attach(h3, 2, 0, 1, 1)

        self.lbl_tracking_proc = self.value_label("‚Ä¶")
        self.lbl_server_proc = self.value_label("‚Ä¶")
        self.lbl_vr_proc = self.value_label("‚Ä¶")

        self.lbl_tracking_name = self.small_muted("Tracking")
        proc_grid.attach(self.lbl_tracking_name, 0, 1, 1, 1)
        proc_grid.attach(self.small_muted("1"), 1, 1, 1, 1)
        proc_grid.attach(self.lbl_tracking_proc, 2, 1, 1, 1)

        self.lbl_server_name = self.small_muted("Server")
        proc_grid.attach(self.lbl_server_name, 0, 2, 1, 1)
        proc_grid.attach(self.small_muted("2"), 1, 2, 1, 1)
        proc_grid.attach(self.lbl_server_proc, 2, 2, 1, 1)

        self.lbl_vr_name = self.small_muted("VR App")
        proc_grid.attach(self.lbl_vr_name, 0, 3, 1, 1)
        proc_grid.attach(self.small_muted("3"), 1, 3, 1, 1)
        proc_grid.attach(self.lbl_vr_proc, 2, 3, 1, 1)

        self.lbl_order_note = self.small_muted("")
        self.lbl_order_note.set_line_wrap(True)
        proc_grid.attach(self.lbl_order_note, 0, 4, 3, 1)

        box.pack_start(proc_grid, False, False, 0)

        hint = Gtk.Label(xalign=0)
        hint.set_line_wrap(True)
        hint.set_text(
            "Tip: If the stack won't start from the desktop, check that your OpenXR runtime is set correctly and that tracking app/VR streaming server/VR app commands exist."
        )
        box.pack_start(hint, False, False, 0)

        return self.wrap_scroller(box)

    def refresh_status(self):
        rc, s = systemctl_user("is-active", "vr-stack-control.service")
        svc_active = (rc == 0 and s == "active")
        self.lbl_service.set_text("RUNNING" if svc_active else "STOPPED")
        # GUI-scoped autostart (starts the stack when this app opens)
        auto_on_open = bool(self.state.get('autostart_on_open', False))
        self.lbl_autostart.set_text('ON APP OPEN' if auto_on_open else 'OFF')

        # Keep the quickbar toggle in sync
        try:
            self._updating_autostart = True
            if hasattr(self, 'btn_quick_autostart'):
                self.btn_quick_autostart.set_active(auto_on_open)
        finally:
            self._updating_autostart = False

        self.lbl_profile.set_text(self.cfg.get("profile", "default"))


        t = s = v = None
        # Live process detection (best-effort)
        try:
            tracking_pat = self.cfg.get("tracking_ready") or self.name_tracking
            server_pat = self.cfg.get("server_pgrep") or self.name_server
            vr_pat = self.cfg.get("vr_pgrep") or self.name_vr

            t = pgrep_first(tracking_pat)
            s = pgrep_first(server_pat)
            v = pgrep_first(vr_pat)

            def fmt(x):
                if not x:
                    return "Not detected"
                pid, cmd = x
                # keep it short
                short = cmd
                if len(short) > 80:
                    short = short[:77] + "..."
                return f"PID {pid}: {short}"

            if hasattr(self, "lbl_tracking_proc"):
                self.lbl_tracking_proc.set_text(fmt(t))
            if hasattr(self, "lbl_server_proc"):
                self.lbl_server_proc.set_text(fmt(s))
            if hasattr(self, "lbl_vr_proc"):
                self.lbl_vr_proc.set_text(fmt(v))

            note = ""
            if v and not s:
                note = f"‚ö† {self.name_vr} is running but {self.name_server} was not detected. Usually you want the server running before the VR app."
            elif s and not t:
                note = f"‚ö† {self.name_server} is running but {self.name_tracking} was not detected. Usually you start tracking first."
            elif (t and s and v):
                note = "‚úì All three parts are running. Expected order is 1‚Üí2‚Üí3."
            else:
                note = ""

            if hasattr(self, "lbl_order_note"):
                self.lbl_order_note.set_text(note)
        except Exception:
            # Don't break the UI if pgrep is missing or patterns are invalid
            if hasattr(self, "lbl_order_note"):
                self.lbl_order_note.set_text("")

        stack_running = svc_active or bool(t or s or v)
        self.stack_running = stack_running
        self.update_quick_controls(stack_running)

        self.last_refresh = time.time()
        return True

    # ---------------- Apps & Settings ----------------
    def build_apps_view(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)

        box.pack_start(self.section_header("What gets launched"), False, False, 0)

        grid = Gtk.Grid(column_spacing=10, row_spacing=8)
        box.pack_start(grid, False, False, 0)

        self.entry_tracking_name = Gtk.Entry()
        self.entry_server_name = Gtk.Entry()
        self.entry_vr_name = Gtk.Entry()

        self.entry_tracking_cmd = Gtk.Entry()
        self.entry_server_cmd = Gtk.Entry()
        self.entry_vr_cmd = Gtk.Entry()
        self.entry_tracking_ready = Gtk.Entry()
        self.entry_server_pgrep = Gtk.Entry()
        self.entry_vr_pgrep = Gtk.Entry()

        self.entry_tracking_name.set_text(self.cfg.get("tracking_name","SlimeVR"))
        self.entry_server_name.set_text(self.cfg.get("server_name","WiVRn"))
        self.entry_vr_name.set_text(self.cfg.get("vr_name","WayVR"))

        self.entry_tracking_cmd.set_text(self.cfg["tracking_cmd"])
        self.entry_server_cmd.set_text(self.cfg["server_cmd"])
        self.entry_vr_cmd.set_text(self.cfg["vr_cmd"])
        self.entry_tracking_ready.set_text(self.cfg["tracking_ready"])
        self.entry_server_pgrep.set_text(self.cfg["server_pgrep"])
        self.entry_vr_pgrep.set_text(self.cfg["vr_pgrep"])
        # Auto-fill launch commands from app names (PATH -> .desktop -> hints -> running process).
        self._auto_cmd = getattr(self, "_auto_cmd", {})
        self.entry_tracking_name.connect("changed", lambda *_: self._on_app_name_changed("tracking"))
        self.entry_server_name.connect("changed", lambda *_: self._on_app_name_changed("server"))
        self.entry_vr_name.connect("changed", lambda *_: self._on_app_name_changed("vr"))

        # Track manual edits so we don't keep overwriting user changes.
        self.entry_tracking_cmd.connect("changed", lambda *_: self._on_cmd_edited("tracking"))
        self.entry_server_cmd.connect("changed", lambda *_: self._on_cmd_edited("server"))
        self.entry_vr_cmd.connect("changed", lambda *_: self._on_cmd_edited("vr"))

        self._autofill_all_from_names()


        # Tracking ON/OFF
        self.switch_tracking_enabled = Gtk.Switch()
        self.switch_tracking_enabled.set_active(str(self.cfg.get('tracking_enabled','true')).lower() in ('1','true','yes','on'))

        r = 0
        r = self._grid_row_switch(grid, r, "Tracking enabled", self.switch_tracking_enabled,
                                 "Turn OFF to start the stack without tracking software (e.g. no full-body tracking).")
        r = self._grid_entry(grid, r, "Tracking app name", self.entry_tracking_name,
                             "Type the app name (e.g. SlimeVR). We will auto-detect a stable launch command.")
        r = self._grid_entry_cmd(grid, r, "Tracking command", self.entry_tracking_cmd, "tracking_cmd",
                             "Started first. Your tracking software (binary, script, or AppImage).")
        r = self._grid_entry(grid, r, "Tracking ready pattern", self.entry_tracking_ready,
                             "We wait for this to appear in process list before starting VR streaming server.")
        r = self._grid_entry(grid, r, "Server app name", self.entry_server_name,
                             "Type the app name (e.g. WiVRn). We will auto-detect the server command.")
        r = self._grid_entry_cmd(grid, r, "Server command", self.entry_server_cmd, "server_cmd",
                             "Started second. Your VR streaming server.")
        r = self._grid_entry(grid, r, "Server pgrep pattern", self.entry_server_pgrep,
                             "Used to detect if the server is already running (avoid duplicates).")
        r = self._grid_entry(grid, r, "VR app name", self.entry_vr_name,
                             "Type the app name (e.g. WayVR). We will auto-detect the VR app command.")
        r = self._grid_entry_cmd(grid, r, "VR app command", self.entry_vr_cmd, "vr_cmd",
                             "Started last. Your PC VR app (OpenXR).")
        r = self._grid_entry(grid, r, "VR app pgrep pattern", self.entry_vr_pgrep,
                             "Used to detect if your VR app is already running.")

        btn_row = Gtk.Box(spacing=10)
        box.pack_start(btn_row, False, False, 0)

        btn_save = Gtk.Button(label="Save settings")
        btn_save.set_image(Gtk.Image.new_from_icon_name("document-save", Gtk.IconSize.BUTTON))
        btn_save.set_always_show_image(True)
        btn_save.connect("clicked", lambda *_: self.on_save_settings())

        btn_defaults = Gtk.Button(label="Reset to defaults")
        btn_defaults.set_image(Gtk.Image.new_from_icon_name("edit-undo", Gtk.IconSize.BUTTON))
        btn_defaults.set_always_show_image(True)
        btn_defaults.connect("clicked", lambda *_: self.on_reset_defaults())

        btn_row.pack_start(btn_save, False, False, 0)
        btn_row.pack_start(btn_defaults, False, False, 0)

        help_block = Gtk.Label(xalign=0)
        help_block.set_line_wrap(True)
        help_block.set_text(
            "Why this matters: these settings are exactly what your start script / systemd service launches. "
            "If a command is wrong, the stack will fail or start the wrong thing. The pgrep patterns prevent duplicate launches."
        )
        box.pack_start(help_block, False, False, 0)

        # Detected runtime / helper paths (read-only)
        box.pack_start(Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL), False, False, 6)

        box.pack_start(self.section_header("Detected paths"), False, False, 0)
        dgrid = Gtk.Grid(column_spacing=10, row_spacing=8)
        box.pack_start(dgrid, False, False, 0)

        # Entry widgets
        # Active runtime and WiVRn are informational (read-only). Others are editable overrides (type or Browse‚Ä¶).
        self.entry_path_openxr_active = Gtk.Entry(); self._make_ro(self.entry_path_openxr_active)
        self.entry_path_openxr_wivrn  = Gtk.Entry(); self._make_ro(self.entry_path_openxr_wivrn)

        self.entry_path_openxr_steamvr = Gtk.Entry()
        self.entry_path_steamvr_root = Gtk.Entry()
        self.entry_path_xrizer = Gtk.Entry()
        self.entry_path_openvrpaths = Gtk.Entry()

        # Allow typing overrides directly
        self._bind_entry_override(self.entry_path_openxr_steamvr, "override_steamvr_openxr_json")
        self._bind_entry_override(self.entry_path_steamvr_root, "override_steamvr_root")
        self._bind_entry_override(self.entry_path_xrizer, "override_xrizer_root")
        self._bind_entry_override(self.entry_path_openvrpaths, "override_openvrpaths")

        # Status labels
        self.lbl_path_openxr_active = Gtk.Label(xalign=0)
        self.lbl_path_openxr_wivrn = Gtk.Label(xalign=0)
        self.lbl_path_openxr_steamvr = Gtk.Label(xalign=0)
        self.lbl_path_steamvr_root = Gtk.Label(xalign=0)
        self.lbl_path_xrizer = Gtk.Label(xalign=0)
        self.lbl_path_openvrpaths = Gtk.Label(xalign=0)

        dr = 0
        dr = self._grid_path(dgrid, dr, "Active OpenXR runtime", self.entry_path_openxr_active, self.lbl_path_openxr_active, None,
                             "Resolved target of ~/.config/openxr/1/active_runtime.json")
        dr = self._grid_path(dgrid, dr, "WiVRn OpenXR JSON", self.entry_path_openxr_wivrn, self.lbl_path_openxr_wivrn, None,
                             "/usr/share/openxr/1/openxr_wivrn.json")
        dr = self._grid_path(dgrid, dr, "SteamVR OpenXR JSON", self.entry_path_openxr_steamvr, self.lbl_path_openxr_steamvr,
                             ("file","override_steamvr_openxr_json"),
                             "SteamVR OpenXR runtime file (steamxr_linux64.json)")
        dr = self._grid_path(dgrid, dr, "SteamVR OpenVR root", self.entry_path_steamvr_root, self.lbl_path_steamvr_root,
                             ("dir","override_steamvr_root"),
                             "SteamVR runtime directory (contains bin/ and drivers/)")
        dr = self._grid_path(dgrid, dr, "XRizer root", self.entry_path_xrizer, self.lbl_path_xrizer,
                             ("dir","override_xrizer_root"),
                             "OpenVR‚ÜíOpenXR bridge directory (used only when enabled)")
        dr = self._grid_path(dgrid, dr, "openvrpaths.vrpath", self.entry_path_openvrpaths, self.lbl_path_openvrpaths,
                             ("file","override_openvrpaths"),
                             "OpenVR paths file (Steam config).")

        btn_row2 = Gtk.Box(spacing=10)

        btn_paths = Gtk.Button(label="Refresh detected paths")
        btn_paths.connect("clicked", lambda *_: self.update_detected_paths())

        btn_repair = Gtk.Button(label="Repair openvrpaths.vrpath")
        btn_repair.set_tooltip_text("Ensure a canonical OpenVR paths file at ~/.local/share/openvr/openvrpaths.vrpath and symlink ~/.config/openvr/openvrpaths.vrpath and Steam config files to it.")
        btn_repair.connect("clicked", lambda *_: self.repair_openvrpaths())

        btn_row2.pack_start(btn_paths, False, False, 0)
        btn_row2.pack_start(btn_repair, False, False, 0)
        box.pack_start(btn_row2, False, False, 0)

        # Fill on first open
        self.update_detected_paths()

        return self.wrap_scroller(box)

    def on_save_settings(self):
        self.cfg["tracking_name"] = self.entry_tracking_name.get_text().strip()
        self.cfg["server_name"] = self.entry_server_name.get_text().strip()
        self.cfg["vr_name"] = self.entry_vr_name.get_text().strip()
        self.cfg["tracking_enabled"] = 'true' if self.switch_tracking_enabled.get_active() else 'false'
        # keep compatibility with the runner; we don't expose this in UI
        self.cfg["tracking_stop_when_disabled"] = 'true'
        self.cfg["tracking_cmd"] = self.entry_tracking_cmd.get_text().strip()
        self.cfg["server_cmd"] = self.entry_server_cmd.get_text().strip()
        self.cfg["vr_cmd"] = self.entry_vr_cmd.get_text().strip()
        self.cfg["tracking_ready"] = self.entry_tracking_ready.get_text().strip()
        self.cfg["server_pgrep"] = self.entry_server_pgrep.get_text().strip()
        self.cfg["vr_pgrep"] = self.entry_vr_pgrep.get_text().strip()
        cfg_save(self.cfg)
        info_dialog(self, "Saved", f"Saved to {STACK_CONF}")
        self.refresh_status()

    def on_reset_defaults(self):
        if not confirm_dialog(self, "Reset to defaults?", "This will overwrite your current commands and patterns."):
            return
        for k, v in DEFAULTS.items():
            self.cfg[k] = v
        self.entry_tracking_name.set_text(self.cfg.get("tracking_name","SlimeVR"))
        self.entry_server_name.set_text(self.cfg.get("server_name","WiVRn"))
        self.entry_vr_name.set_text(self.cfg.get("vr_name","WayVR"))
        self.entry_tracking_cmd.set_text(self.cfg["tracking_cmd"])
        self.entry_server_cmd.set_text(self.cfg["server_cmd"])
        self.entry_vr_cmd.set_text(self.cfg["vr_cmd"])
        self.entry_tracking_ready.set_text(self.cfg["tracking_ready"])
        self.entry_server_pgrep.set_text(self.cfg["server_pgrep"])
        self.entry_vr_pgrep.set_text(self.cfg["vr_pgrep"])
        cfg_save(self.cfg)
        info_dialog(self, "Reset", "Defaults restored.")
        self.refresh_status()

    # ---------------- Actions ----------------
    def build_actions_view(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)

        box.pack_start(self.section_header("One-click actions"), False, False, 0)

        grid = Gtk.Grid(column_spacing=10, row_spacing=8)
        box.pack_start(grid, False, False, 0)

        # Stack + tray
        self.combo_stack = Gtk.ComboBoxText()
        for k, label in (
            ("none", "Do nothing"),
            ("start", "Start stack"),
            ("restart", "Restart stack"),
            ("stop", "Stop stack"),
            ("enable", "Enable autostart"),
            ("disable", "Disable autostart"),
        ):
            self.combo_stack.append(k, label)

        # App settings actions (these are "safe" UI actions)
        self.combo_tracking = Gtk.ComboBoxText()
        self.combo_server = Gtk.ComboBoxText()
        self.combo_vr = Gtk.ComboBoxText()
        self.combo_patterns = Gtk.ComboBoxText()

        for combo in (self.combo_tracking, self.combo_server, self.combo_vr, self.combo_patterns):
            combo.append("none", "Do nothing")
            combo.append("edit", "Edit settings (jump to Apps & Settings)")
            combo.append("reset", "Reset to defaults")

        # restore last selections
        self._combo_set(self.combo_stack, self.state.get("action_stack", "none"))
        self._combo_set(self.combo_tracking, self.state.get("action_tracking", "none"))
        self._combo_set(self.combo_server, self.state.get("action_server", "none"))
        self._combo_set(self.combo_vr, self.state.get("action_vr", "none"))
        self._combo_set(self.combo_patterns, self.state.get("action_patterns", "none"))

        for name, combo in (
            ("action_stack", self.combo_stack),
            ("action_tracking", self.combo_tracking),
            ("action_server", self.combo_server),
            ("action_vr", self.combo_vr),
            ("action_patterns", self.combo_patterns),
        ):
            combo.connect("changed", lambda c, n=name: self.on_combo_changed(n, c))

        r = 0
        r = self._grid_row_combo(grid, r, "VR stack", self.combo_stack, "Start/stop the VR stack service (launches tracking app ‚Üí VR streaming server ‚Üí VR app in order).")
        r = self._grid_row_combo(grid, r, "Tracking settings", self.combo_tracking, "Tracking app settings (usually tracking app). Change this if you moved/renamed the tracking app AppImage or want a different tracker app.")
        r = self._grid_row_combo(grid, r, "Server settings", self.combo_server, "VR streaming server server settings (streams VR to your Quest). Change only if you installed VR streaming server somewhere unusual.")
        r = self._grid_row_combo(grid, r, "VR app settings", self.combo_vr, "VR app settings (usually VR app). This is the app that opens on your PC and uses OpenXR.")
        r = self._grid_row_combo(grid, r, "Patterns", self.combo_patterns, "How the app checks what is running (advanced). Leave this alone unless detection is wrong.")

        btn_row = Gtk.Box(spacing=10)
        box.pack_start(btn_row, False, False, 0)

        btn_apply = Gtk.Button(label="Apply")
        btn_apply.set_image(Gtk.Image.new_from_icon_name("system-run", Gtk.IconSize.BUTTON))
        btn_apply.set_always_show_image(True)
        btn_apply.connect("clicked", lambda *_: self.on_apply_actions())

        btn_row.pack_start(btn_apply, False, False, 0)

        hint = Gtk.Label(xalign=0)
        hint.set_line_wrap(True)
        hint.set_text(
            "Selections are saved automatically. If you close and reopen the GUI, your dropdown choices will still be set."
        )
        box.pack_start(hint, False, False, 0)

        return self.wrap_scroller(box)

    def on_combo_changed(self, key, combo: Gtk.ComboBoxText):
        self.state[key] = combo.get_active_id() or "none"
        state_save(self.state)

    def on_apply_actions(self):
        choices = {
            "Stack": self.combo_stack.get_active_text(),
            "Tracking": self.combo_tracking.get_active_text(),
            "Server": self.combo_server.get_active_text(),
            "VR app": self.combo_vr.get_active_text(),
            "Patterns": self.combo_patterns.get_active_text(),
        }
        summary = "\n".join([f"{k}: {v}" for k, v in choices.items()])
        if not confirm_dialog(self, "Apply these actions?", summary):
            return

        # stack + tray actions (systemd)
        self.apply_systemd_action("vr-stack-control.service", self.combo_stack.get_active_id())
        
        # app settings actions
        self.apply_settings_action(self.combo_tracking.get_active_id(), scope="tracking")
        self.apply_settings_action(self.combo_server.get_active_id(), scope="server")
        self.apply_settings_action(self.combo_vr.get_active_id(), scope="vr")
        self.apply_settings_action(self.combo_patterns.get_active_id(), scope="patterns")

        self.refresh_status()
        info_dialog(self, "Done", "Actions applied.")

    def apply_systemd_action(self, unit: str, action: str):
        if action in (None, "none"):
            return
        if action == "start":
            systemctl_user("start", unit)
        elif action == "stop":
            systemctl_user("stop", unit)
        elif action == "restart":
            systemctl_user("restart", unit)
        elif action == "enable":
            systemctl_user("enable", unit)
        elif action == "disable":
            systemctl_user("disable", unit)

    def apply_settings_action(self, action: str, scope: str):
        if action in (None, "none"):
            return
        if action == "edit":
            self.stack.set_visible_child_name("apps")
            return
        if action == "reset":
            if scope == "tracking":
                self.cfg["tracking_cmd"] = DEFAULTS["tracking_cmd"]
                self.cfg["tracking_ready"] = DEFAULTS["tracking_ready"]
                self.entry_tracking_cmd.set_text(self.cfg["tracking_cmd"])
                self.entry_tracking_ready.set_text(self.cfg["tracking_ready"])
            elif scope == "server":
                self.cfg["server_cmd"] = DEFAULTS["server_cmd"]
                self.cfg["server_pgrep"] = DEFAULTS["server_pgrep"]
                self.entry_server_cmd.set_text(self.cfg["server_cmd"])
                self.entry_server_pgrep.set_text(self.cfg["server_pgrep"])
            elif scope == "vr":
                self.cfg["vr_cmd"] = DEFAULTS["vr_cmd"]
                self.cfg["vr_pgrep"] = DEFAULTS["vr_pgrep"]
                self.entry_vr_cmd.set_text(self.cfg["vr_cmd"])
                self.entry_vr_pgrep.set_text(self.cfg["vr_pgrep"])
            elif scope == "patterns":
                self.cfg["tracking_ready"] = DEFAULTS["tracking_ready"]
                self.cfg["server_pgrep"] = DEFAULTS["server_pgrep"]
                self.cfg["vr_pgrep"] = DEFAULTS["vr_pgrep"]
                self.entry_tracking_ready.set_text(self.cfg["tracking_ready"])
                self.entry_server_pgrep.set_text(self.cfg["server_pgrep"])
                self.entry_vr_pgrep.set_text(self.cfg["vr_pgrep"])
            cfg_save(self.cfg)

    # ---------------- Profiles ----------------
    def build_profiles_view(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)

        box.pack_start(self.section_header("Profiles"), False, False, 0)

        top = Gtk.Box(spacing=10)
        box.pack_start(top, False, False, 0)

        self.combo_profile = Gtk.ComboBoxText()
        self.refresh_profiles_combo()
        self._combo_set(self.combo_profile, self.cfg.get("profile", "default"))

        self.combo_profile.connect("changed", lambda *_: None)

        btn_select = Gtk.Button(label="Set as active")
        btn_select.set_image(Gtk.Image.new_from_icon_name("emblem-ok", Gtk.IconSize.BUTTON))
        btn_select.set_always_show_image(True)
        btn_select.connect("clicked", lambda *_: self.on_set_profile())

        top.pack_start(Gtk.Label(label="Profile:", xalign=0), False, False, 0)
        top.pack_start(self.combo_profile, False, False, 0)
        top.pack_start(btn_select, False, False, 0)

        # list + actions
        self.profile_list = Gtk.ListBox()
        self.profile_list.set_selection_mode(Gtk.SelectionMode.SINGLE)
        box.pack_start(self.profile_list, True, True, 0)

        btns = Gtk.Box(spacing=10)
        box.pack_start(btns, False, False, 0)

        btn_new = Gtk.Button(label="New")
        btn_new.set_image(Gtk.Image.new_from_icon_name("list-add", Gtk.IconSize.BUTTON))
        btn_new.set_always_show_image(True)
        btn_new.connect("clicked", lambda *_: self.on_new_profile())

        btn_rename = Gtk.Button(label="Rename")
        btn_rename.set_image(Gtk.Image.new_from_icon_name("edit-rename", Gtk.IconSize.BUTTON))
        btn_rename.set_always_show_image(True)
        btn_rename.connect("clicked", lambda *_: self.on_rename_profile())

        btn_delete = Gtk.Button(label="Delete")
        btn_delete.set_image(Gtk.Image.new_from_icon_name("edit-delete", Gtk.IconSize.BUTTON))
        btn_delete.set_always_show_image(True)
        btn_delete.connect("clicked", lambda *_: self.on_delete_profile())

        btn_edit = Gtk.Button(label="Edit")
        btn_edit.set_image(Gtk.Image.new_from_icon_name("document-edit", Gtk.IconSize.BUTTON))
        btn_edit.set_always_show_image(True)
        btn_edit.connect("clicked", lambda *_: self.on_edit_profile())

        btns.pack_start(btn_new, False, False, 0)
        btns.pack_start(btn_edit, False, False, 0)
        btns.pack_start(btn_rename, False, False, 0)
        btns.pack_start(btn_delete, False, False, 0)

        help_block = Gtk.Label(xalign=0)
        help_block.set_line_wrap(True)
        help_block.set_text(
            "Profiles let you save different app commands/patterns for different setups (e.g. VR streaming server vs something else). "
            "This GUI stores profiles as simple .conf files under ~/.config/vr-stack/profiles/."
        )
        box.pack_start(help_block, False, False, 0)

        self.refresh_profiles_list()
        return self.wrap_scroller(box)

    def profiles(self):
        files = sorted(PROFILES_DIR.glob("*.conf"))
        out = []
        for f in files:
            out.append((f.stem, f))
        # ensure default exists
        default_path = PROFILES_DIR / "default.conf"
        if not default_path.exists():
            write_kv(default_path, DEFAULTS.copy())
        if ("default", default_path) not in out:
            out.insert(0, ("default", default_path))
        return out

    def refresh_profiles_combo(self):
        self.combo_profile.remove_all()
        for name, _ in self.profiles():
            self.combo_profile.append(name, name)

    def refresh_profiles_list(self):
        for row in list(self.profile_list.get_children()):
            self.profile_list.remove(row)
        for name, path in self.profiles():
            row = Gtk.ListBoxRow()
            h = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            row.add(h)
            lbl = Gtk.Label(label=name, xalign=0)
            sub = Gtk.Label(label=str(path), xalign=0)
            sub.get_style_context().add_class("dim-label")
            v = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
            v.pack_start(lbl, False, False, 0)
            v.pack_start(sub, False, False, 0)
            h.pack_start(v, True, True, 0)
            row.profile_name = name
            row.profile_path = path
            self.profile_list.add(row)
        self.profile_list.show_all()

    def selected_profile_row(self):
        return self.profile_list.get_selected_row()

    def on_set_profile(self):
        name = self.combo_profile.get_active_id() or "default"
        self.cfg["profile"] = name
        cfg_save(self.cfg)
        self.refresh_status()
        info_dialog(self, "Profile set", f"Active profile set to: {name}\n\nNote: your start script/service must load and apply the profile file for this to affect launches.")

    def ask_text(self, title, prompt, initial=""):
        d = Gtk.Dialog(title, self, 0, ("Cancel", Gtk.ResponseType.CANCEL, "OK", Gtk.ResponseType.OK))
        box = d.get_content_area()
        box.set_spacing(8)
        box.pack_start(Gtk.Label(label=prompt, xalign=0), False, False, 0)
        entry = Gtk.Entry()
        entry.set_text(initial)
        box.pack_start(entry, False, False, 0)
        d.show_all()
        rc = d.run()
        txt = entry.get_text().strip()
        d.destroy()
        if rc == Gtk.ResponseType.OK and txt:
            return txt
        return None

    def on_new_profile(self):
        name = self.ask_text("New profile", "Profile name (letters/numbers/dash):")
        if not name:
            return
        path = PROFILES_DIR / f"{name}.conf"
        if path.exists():
            info_dialog(self, "Exists", "That profile already exists.")
            return
        write_kv(path, DEFAULTS.copy())
        self.refresh_profiles_combo()
        self.refresh_profiles_list()
        self._combo_set(self.combo_profile, name)
        info_dialog(self, "Created", f"Created {path}")

    def on_rename_profile(self):
        row = self.selected_profile_row()
        if not row:
            info_dialog(self, "No selection", "Select a profile first.")
            return
        if row.profile_name == "default":
            info_dialog(self, "Not allowed", "You can't rename the default profile.")
            return
        newname = self.ask_text("Rename profile", "New name:", row.profile_name)
        if not newname:
            return
        newpath = PROFILES_DIR / f"{newname}.conf"
        if newpath.exists():
            info_dialog(self, "Exists", "A profile with that name already exists.")
            return
        row.profile_path.rename(newpath)
        # update active profile if needed
        if self.cfg.get("profile") == row.profile_name:
            self.cfg["profile"] = newname
            cfg_save(self.cfg)
        self.refresh_profiles_combo()
        self.refresh_profiles_list()
        self._combo_set(self.combo_profile, self.cfg.get("profile", "default"))

    def on_delete_profile(self):
        row = self.selected_profile_row()
        if not row:
            info_dialog(self, "No selection", "Select a profile first.")
            return
        if row.profile_name == "default":
            info_dialog(self, "Not allowed", "You can't delete the default profile.")
            return
        if not confirm_dialog(self, "Delete profile?", f"Delete {row.profile_name} ?\n{row.profile_path}"):
            return
        try:
            row.profile_path.unlink()
        except Exception as e:
            info_dialog(self, "Error", str(e))
        if self.cfg.get("profile") == row.profile_name:
            self.cfg["profile"] = "default"
            cfg_save(self.cfg)
        self.refresh_profiles_combo()
        self.refresh_profiles_list()
        self._combo_set(self.combo_profile, self.cfg.get("profile", "default"))
        self.refresh_status()

    def on_edit_profile(self):
        row = self.selected_profile_row()
        if not row:
            info_dialog(self, "No selection", "Select a profile first.")
            return
        # Use editor if set, else xdg-open
        editor = os.environ.get("EDITOR")
        if editor:
            subprocess.Popen([editor, str(row.profile_path)])
        else:
            subprocess.Popen(["xdg-open", str(row.profile_path)])

    # ---------------- Debug ----------------
    def build_debug_view(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.pack_start(self.section_header("Debug"), False, False, 0)

        self.txt_debug = Gtk.TextView()
        self.txt_debug.set_editable(False)
        self.txt_debug.set_monospace(True)

        btn_row = Gtk.Box(spacing=10)
        btn_refresh = Gtk.Button(label="Refresh")
        btn_refresh.set_image(Gtk.Image.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON))
        btn_refresh.set_always_show_image(True)
        btn_refresh.connect("clicked", lambda *_: self.refresh_debug())
        btn_row.pack_start(btn_refresh, False, False, 0)

        box.pack_start(btn_row, False, False, 0)
        box.pack_start(self.wrap_scroller(self.txt_debug), True, True, 0)

        self.refresh_debug()
        return box

    def refresh_debug(self):
        lines = []
        lines.append(f"Version: {APP_VERSION}")
        lines.append(f"Config: {STACK_CONF}")
        lines.append(f"Profiles: {PROFILES_DIR}")
        lines.append(f"GUI state: {GUI_STATE}")
        lines.append("")
        lines.append("systemctl --user status vr-stack-control.service")
        rc, out = systemctl_user("status", "vr-stack-control.service", "--no-pager", "-l")
        lines.append(out)
        lines.append("")

        buf = self.txt_debug.get_buffer()
        buf.set_text("\n".join(lines))

    # ---------------- helpers ----------------
    def section_header(self, text):
        lbl = Gtk.Label()
        lbl.set_markup(f"<span size='x-large' weight='bold'>{GLib.markup_escape_text(text)}</span>")
        lbl.set_xalign(0)
        return lbl

    def small_muted(self, text):
        # Small, muted left-aligned label (for table headings / hints)
        safe = GLib.markup_escape_text(str(text))
        lbl = Gtk.Label()
        lbl.set_xalign(0)
        lbl.set_use_markup(True)
        lbl.set_markup(f"<span size='small' alpha='700'>{safe}</span>")
        return lbl

    def value_label(self, text, monospace=False):
        lbl = Gtk.Label(label=str(text))
        lbl.set_xalign(0)
        lbl.set_yalign(0.5)
        lbl.set_selectable(True)
        lbl.set_hexpand(True)
        lbl.set_line_wrap(True)
        lbl.set_max_width_chars(80)
        if monospace:
            try:
                lbl.get_style_context().add_class("monospace")
            except Exception:
                pass
        return lbl


    def wrap_scroller(self, child):
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        sw.add(child)
        return sw

    def _grid_row(self, grid, row, label, widget):
        l = Gtk.Label(label=label, xalign=0)
        grid.attach(l, 0, row, 1, 1)
        grid.attach(widget, 1, row, 1, 1)

    def _grid_row_switch(self, grid, row, label, sw, why):
        l = Gtk.Label(label=label, xalign=0)
        grid.attach(l, 0, row, 1, 1)
        grid.attach(sw, 1, row, 1, 1)
        w = Gtk.Label(label=why, xalign=0)
        w.set_line_wrap(True)
        w.get_style_context().add_class("dim-label")
        grid.attach(w, 2, row, 1, 1)
        return row + 1

    def _grid_row_combo(self, grid, row, label, combo, why):
        l = Gtk.Label(label=label, xalign=0)
        grid.attach(l, 0, row, 1, 1)
        grid.attach(combo, 1, row, 1, 1)
        w = Gtk.Label(label=why, xalign=0)
        w.set_line_wrap(True)
        w.get_style_context().add_class("dim-label")
        grid.attach(w, 2, row, 1, 1)
        return row + 1

    def _grid_entry(self, grid, row, label, entry, why):
        l = Gtk.Label(label=label, xalign=0)
        grid.attach(l, 0, row, 1, 1)
        grid.attach(entry, 1, row, 1, 1)
        w = Gtk.Label(label=why, xalign=0)
        w.set_line_wrap(True)
        w.get_style_context().add_class("dim-label")
        grid.attach(w, 2, row, 1, 1)
        return row + 1

    def _browse_command(self, entry: Gtk.Entry, cfg_key: str):
        """Select an executable/script/AppImage and set it as a command."""
        dlg = Gtk.FileChooserDialog(
            title="Select command",
            parent=self,
            action=Gtk.FileChooserAction.OPEN,
        )
        dlg.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OPEN, Gtk.ResponseType.OK)
        resp = dlg.run()
        if resp == Gtk.ResponseType.OK:
            chosen = dlg.get_filename()
            if chosen:
                entry.set_text(chosen)
                self.cfg[cfg_key] = chosen
                try:
                    self.save_config()
                except Exception:
                    pass
                try:
                    self.update_display_names()
                except Exception:
                    pass
        dlg.destroy()


    def _cmd_is_valid(self, cmd: str) -> bool:
        c = (cmd or "").strip()
        if not c:
            return False
        try:
            tok = shlex.split(c)[0]
        except Exception:
            tok = c.split(" ", 1)[0]
        if tok.startswith("/"):
            return os.path.exists(tok) and os.access(tok, os.X_OK)
        return shutil.which(tok) is not None

    def _autofill_one_from_name(self, kind: str):
        if not hasattr(self, "_auto_cmd"):
            self._auto_cmd = {}

        if kind == "tracking":
            name = self.entry_tracking_name.get_text().strip()
            entry = self.entry_tracking_cmd
            default = DEFAULTS.get("tracking_cmd", "")
        elif kind == "server":
            name = self.entry_server_name.get_text().strip()
            entry = self.entry_server_cmd
            default = DEFAULTS.get("server_cmd", "")
        else:
            name = self.entry_vr_name.get_text().strip()
            entry = self.entry_vr_cmd
            default = DEFAULTS.get("vr_cmd", "")

        cur = entry.get_text().strip()
        detected = detect_command_by_name(name, kind=kind)

        # Only overwrite if the current value looks auto / empty / invalid.
        prev_auto = (self._auto_cmd.get(kind) or "").strip()
        should_overwrite = (
            (not cur) or
            (cur == prev_auto) or
            (cur == default) or
            (not self._cmd_is_valid(cur))
        )

        if detected and should_overwrite:
            # Avoid writing obviously-unstable AppImage mounts
            if "/tmp/.mount_" in detected or "/tmp/appimage_extracted_" in detected:
                return
            entry.set_text(detected)
            self._auto_cmd[kind] = detected

    def _autofill_all_from_names(self):
        self._autofill_one_from_name("tracking")
        self._autofill_one_from_name("server")
        self._autofill_one_from_name("vr")

    def _on_app_name_changed(self, kind: str):
        # Auto-fill immediately when the user types the name.
        self._autofill_one_from_name(kind)

    def _on_cmd_edited(self, kind: str):
        # If user clears the command, allow auto-fill again.
        if kind == "tracking":
            cur = self.entry_tracking_cmd.get_text().strip()
        elif kind == "server":
            cur = self.entry_server_cmd.get_text().strip()
        else:
            cur = self.entry_vr_cmd.get_text().strip()
        if not cur and hasattr(self, "_auto_cmd"):
            self._auto_cmd[kind] = ""
    def _grid_entry_cmd(self, grid, row, label, entry: Gtk.Entry, cfg_key: str, why: str):
        """Grid entry row for a command with a Browse‚Ä¶ button."""
        l = Gtk.Label(label=label, xalign=0)
        grid.attach(l, 0, row, 1, 1)

        box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        entry.set_hexpand(True)
        box.pack_start(entry, True, True, 0)
        b = Gtk.Button(label="Browse‚Ä¶")
        b.connect("clicked", lambda *_: self._browse_command(entry, cfg_key))
        box.pack_start(b, False, False, 0)
        grid.attach(box, 1, row, 1, 1)

        w = Gtk.Label(label=why, xalign=0)
        w.set_line_wrap(True)
        w.get_style_context().add_class("dim-label")
        grid.attach(w, 2, row, 1, 1)
        return row + 1


    def _make_ro(self, entry: Gtk.Entry):
        entry.set_editable(False)
        entry.set_can_focus(True)

    def _status_for_path(self, p: str, want: str) -> str:
        # want: "file" or "dir"
        if not p:
            return "‚ö†"
        try:
            pp = Path(p).expanduser()
            # Show warning for dangling symlink (common when Steam paths are linked to ~/.config/openvr then deleted)
            if pp.is_symlink() and not pp.exists():
                return "‚ö†"
            if want == "dir":
                return "‚úî" if pp.is_dir() else "‚ùå"
            return "‚úî" if pp.is_file() else "‚ùå"
        except Exception:
            return "‚ùå"

    def save_config(self):
        cfg_save(self.cfg)

    def _bind_entry_override(self, entry: Gtk.Entry, cfg_key: str):
        # Let users type overrides directly (in addition to Browse‚Ä¶)
        try:
            entry.set_placeholder_text("Leave blank to auto-detect")
        except Exception:
            pass

        def _commit(*_args):
            try:
                val = (entry.get_text() or "").strip()
                if val:
                    self.cfg[cfg_key] = val
                else:
                    if cfg_key in self.cfg:
                        del self.cfg[cfg_key]
                self.save_config()
                self.update_detected_paths()
            except Exception as e:
                self.debug_log(f"Failed to save override {cfg_key}: {e}")
            return False

        entry.connect("activate", _commit)
        entry.connect("focus-out-event", _commit)
    def repair_openvrpaths(self):
        """Ensure a canonical ~/.local/share/openvr/openvrpaths.vrpath and point Steam + ~/.config/openvr to it.

        This is intentionally safe:
        - Never deletes user data (backs up existing real files).
        - If no existing openvrpaths.vrpath can be found, it will try to *generate* a minimal one
          using detected SteamVR install paths.
        """
        try:
            home = Path.home()
            canonical = home / ".local" / "share" / "openvr" / "openvrpaths.vrpath"
            legacy_cfg = home / ".config" / "openvr" / "openvrpaths.vrpath"
            canonical.parent.mkdir(parents=True, exist_ok=True)

            steam_paths = [
                home / ".steam" / "steam" / "config" / "openvrpaths.vrpath",
                home / ".local" / "share" / "Steam" / "config" / "openvrpaths.vrpath",
                home / ".steam" / "root" / "config" / "openvrpaths.vrpath",
            ]

            def _is_real_file(p: Path) -> bool:
                try:
                    return p.exists() and p.is_file() and (not p.is_symlink())
                except Exception:
                    return False

            # 1) If canonical is missing, try to copy from any existing real file.
            if not canonical.exists():
                src = None
                for sp in steam_paths:
                    if _is_real_file(sp):
                        src = sp
                        break

                # 2) If we only have symlinks, try following them to a real file.
                if not src:
                    for sp in steam_paths:
                        try:
                            if sp.is_symlink():
                                tgt = sp.resolve(strict=False)
                                if tgt.exists() and tgt.is_file():
                                    src = tgt
                                    break
                        except Exception:
                            pass

                if src:
                    try:
                        canonical.write_bytes(src.read_bytes())
                    except Exception:
                        import shutil as _sh
                        _sh.copy2(str(src), str(canonical))

            # 3) Still missing? Generate a minimal openvrpaths.vrpath from detected SteamVR paths.
            if not canonical.exists():
                import json

                steamvr_root = (self.cfg.get("override_steamvr_root") or "").strip()
                if not steamvr_root:
                    # Derive from SteamVR OpenXR JSON if we can
                    sj = (self.cfg.get("override_steamvr_openxr_json") or self.find_steamvr_openxr_json() or "").strip()
                    if sj:
                        try:
                            steamvr_root = str(Path(sj).expanduser().parent)
                        except Exception:
                            steamvr_root = ""

                root = Path(steamvr_root).expanduser() if steamvr_root else None
                if root and root.is_file():
                    root = root.parent

                steam_base = None
                if root:
                    # Try to find a parent that looks like a Steam install root (has steamapps/ and config/)
                    for parent in [root] + list(root.parents):
                        try:
                            if (parent / "steamapps").is_dir() and (parent / "config").is_dir():
                                steam_base = parent
                                break
                        except Exception:
                            pass

                # Fallback candidates
                if steam_base is None:
                    for cand in (
                        home / ".steam" / "steam",
                        home / ".local" / "share" / "Steam",
                        home / ".steam" / "root",
                    ):
                        try:
                            if (cand / "config").is_dir() or (cand / "steamapps").is_dir():
                                steam_base = cand
                                break
                        except Exception:
                            pass

                # Generate even if we can't fully detect everything.
                # This prevents runtime switching from getting stuck because openvrpaths.vrpath is missing.
                if steam_base is None:
                    for cand in (
                        home / ".local" / "share" / "Steam",
                        home / ".steam" / "steam",
                        home / ".steam" / "root",
                    ):
                        try:
                            if (cand / "config").is_dir() or (cand / "steamapps").is_dir():
                                steam_base = cand
                                break
                        except Exception:
                            pass

                cfg_dir = (steam_base / "config") if steam_base else (home / ".local" / "share" / "Steam" / "config")
                log_dir = (steam_base / "logs") if steam_base else (home / ".local" / "share" / "Steam" / "logs")
                try:
                    cfg_dir.mkdir(parents=True, exist_ok=True)
                    log_dir.mkdir(parents=True, exist_ok=True)
                except Exception:
                    pass

                runtimes = []
                xr = (self.cfg.get("override_xrizer_root") or "/opt/xrizer").strip() or "/opt/xrizer"
                try:
                    xr_path = Path(xr).expanduser()
                    if xr_path.is_dir():
                        runtimes.append(str(xr_path))
                except Exception:
                    pass

                if root is not None:
                    try:
                        if root.exists():
                            runtimes.append(str(root))
                    except Exception:
                        pass

                if not runtimes:
                    # fall back to common SteamVR install locations
                    for cand in (
                        home / ".local" / "share" / "Steam" / "steamapps" / "common" / "SteamVR",
                        home / ".steam" / "steam" / "steamapps" / "common" / "SteamVR",
                        home / ".steam" / "root" / "steamapps" / "common" / "SteamVR",
                    ):
                        try:
                            if cand.is_dir():
                                runtimes.append(str(cand))
                        except Exception:
                            pass

                # de-duplicate preserving order
                seen = set()
                runtimes = [r for r in runtimes if not (r in seen or seen.add(r))]

                data = {
                    "config": [str(cfg_dir)] if cfg_dir else [],
                    "external_drivers": None,
                    "jsonid": "vrpathreg",
                    "log": [str(log_dir)] if log_dir else [],
                    "runtime": runtimes,
                    "version": 1,
                }
                canonical.write_text(json.dumps(data, indent=2) + "\n")
            if not canonical.exists():
                self.toast("openvrpaths.vrpath not found. Set SteamVR OpenVR root, or start SteamVR once, then click Repair again.")
                return



            # Normalize contents: ensure XRizer is first when present, and de-duplicate runtime entries.
            try:
                import json
                xr = (self.cfg.get("override_xrizer_root") or "/opt/xrizer").strip() or "/opt/xrizer"
                xr_path = Path(xr).expanduser()
                with canonical.open("r", encoding="utf-8") as f:
                    data = json.load(f)
                rt = list(data.get("runtime") or [])
                # de-dup preserving order
                seen = set()
                rt = [x for x in rt if not (x in seen or seen.add(x))]
                if xr_path.is_dir():
                    xr_s = str(xr_path)
                    rt = [x for x in rt if x != xr_s]
                    rt.insert(0, xr_s)
                data["runtime"] = rt
                canonical.write_text(json.dumps(data, indent=2) + "\n", encoding="utf-8")
            except Exception as _e:
                try:
                    self.debug_log(f"repair_openvrpaths: normalize failed: {_e}")
                except Exception:
                    pass
            # Set override to canonical so the UI reflects the canonical path.
            self.cfg["override_openvrpaths"] = str(canonical)
            self.save_config()

            # Also normalize Steam's openvrpaths.vrpath copies (Steam/Pressure-Vessel can use these).
            try:
                import json
                xr = (self.cfg.get("override_xrizer_root") or "/opt/xrizer").strip() or "/opt/xrizer"
                xr_path = Path(xr).expanduser()
                steam_paths2 = [
                    home / ".steam" / "steam" / "config" / "openvrpaths.vrpath",
                    home / ".local" / "share" / "Steam" / "config" / "openvrpaths.vrpath",
                    home / ".steam" / "root" / "config" / "openvrpaths.vrpath",
                ]
                for sp in steam_paths2:
                    try:
                        if not sp.exists() or (not sp.is_file()):
                            continue
                        with sp.open("r", encoding="utf-8") as f:
                            sdata = json.load(f)
                        srt = list(sdata.get("runtime") or [])
                        seen = set()
                        srt = [x for x in srt if not (x in seen or seen.add(x))]
                        if xr_path.is_dir():
                            xr_s = str(xr_path)
                            srt = [x for x in srt if x != xr_s]
                            srt.insert(0, xr_s)
                        sdata["runtime"] = srt
                        sp.write_text(json.dumps(sdata, indent=2) + "\n", encoding="utf-8")
                    except Exception:
                        pass
            except Exception:
                pass

            ts = time.strftime("%Y%m%d-%H%M%S")

            # Also ensure ~/.config/openvr/openvrpaths.vrpath points to the canonical file
            try:
                legacy_cfg.parent.mkdir(parents=True, exist_ok=True)
                if legacy_cfg.exists() and (not legacy_cfg.is_symlink()):
                    backup = legacy_cfg.with_suffix(legacy_cfg.suffix + f".bak.{ts}")
                    try:
                        legacy_cfg.rename(backup)
                    except Exception:
                        pass
                try:
                    if legacy_cfg.is_symlink() or legacy_cfg.exists():
                        legacy_cfg.unlink()
                except Exception:
                    pass
                try:
                    legacy_cfg.symlink_to(canonical)
                except Exception:
                    pass
            except Exception as e:
                self.debug_log(f"repair_openvrpaths: failed for legacy_cfg: {e}")


            

            self.toast("Repaired openvrpaths.vrpath (canonical created + symlinks updated).")
            self.update_detected_paths()
        except Exception as e:
            self.toast(f"Repair failed: {e}")

    def _browse_override(self, kind: str, cfg_key: str):
        # kind: "file" or "dir"
        action = Gtk.FileChooserAction.OPEN if kind == "file" else Gtk.FileChooserAction.SELECT_FOLDER
        dlg = Gtk.FileChooserDialog(
            title="Select " + ("file" if kind == "file" else "folder"),
            parent=self,
            action=action
        )
        dlg.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OPEN, Gtk.ResponseType.OK)
        resp = dlg.run()
        if resp == Gtk.ResponseType.OK:
            chosen = dlg.get_filename()
            if chosen:
                self.cfg[cfg_key] = chosen
                self.save_config()
                self.update_detected_paths()
        dlg.destroy()

    def _grid_path(self, grid, row, label, entry, status_label, browse_tuple, why):
        l = Gtk.Label(label=label, xalign=0)
        grid.attach(l, 0, row, 1, 1)
        grid.attach(entry, 1, row, 1, 1)
        grid.attach(status_label, 2, row, 1, 1)
        if browse_tuple:
            kind, key = browse_tuple
            b = Gtk.Button(label="Browse‚Ä¶")
            b.connect("clicked", lambda *_: self._browse_override(kind, key))
            grid.attach(b, 3, row, 1, 1)
        w = Gtk.Label(label=why, xalign=0)
        w.set_line_wrap(True)
        w.get_style_context().add_class("dim-label")
        grid.attach(w, 4, row, 1, 1)
        return row + 1

    def _combo_set(self, combo: Gtk.ComboBoxText, key: str):
        try:
            combo.set_active_id(key)
        except Exception:
            combo.set_active(0)


def main():
    win = VRControlApp()
    win.connect("destroy", Gtk.main_quit)
    Gtk.main()



if __name__ == "__main__":
    main()
