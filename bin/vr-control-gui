#!/usr/bin/env python3
import os
import time
import json
import subprocess
import shlex
import re
from pathlib import Path

import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk, Gdk, GLib

APP_VERSION = "v0.6.53"

STACK_SERVICE = "vr-stack-control.service"

CONFIG_DIR = Path(os.environ.get("XDG_CONFIG_HOME", Path.home()/".config")) / "vr-stack"
STACK_CONF = CONFIG_DIR / "stack.conf"
PROFILES_DIR = CONFIG_DIR / "profiles"
GUI_STATE = CONFIG_DIR / "gui_state.json"

DEFAULTS = {
    "tracking_cmd": "/opt/slimevr/slimevr",
    "server_cmd": "wivrn-server",
    "vr_cmd": "wayvr",
    "tracking_ready": "slimevr\\.jar",
    "server_pgrep": "wivrn-server",
    "vr_pgrep": "(^|/)(wayvr)(\\s|$)",
    "profile": "default",
    "tracking_enabled": "true",
    "tracking_stop_when_disabled": "true",
    "openxr_json": "/usr/share/openxr/1/openxr_wivrn.json",
    "xr_runtime": "wivrn",
}


def ensure_dirs():
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    PROFILES_DIR.mkdir(parents=True, exist_ok=True)


def read_kv(path: Path):
    """Read a very small KEY=VALUE config file.

    Values may be plain (no spaces/specials) or quoted with single/double quotes.
    We strip surrounding quotes for convenience.
    """
    data = {}
    if not path.exists():
        return data
    for raw in path.read_text(errors="ignore").splitlines():
        line = raw.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        k, v = line.split("=", 1)
        k = k.strip()
        v = v.strip()
        # Strip surrounding quotes if present
        if len(v) >= 2 and ((v[0] == v[-1] == "'") or (v[0] == v[-1] == '"')):
            q = v[0]
            v = v[1:-1]
            if q == "'":
                pass
        data[k] = v
    return data





def _bash_single_quote(val: str) -> str:
    """Return a bash-safe single-quoted string."""
    # Escape for single quotes inside single quotes: 'foo'"'"'bar'
    return "'" + val.replace("'", "'\"'\"'") + "'"

def write_kv(path: Path, data: dict):
    """Write KEY=VALUE config as bash-safe assignments."""
    lines = []
    for k, v in data.items():
        if v is None:
            continue
        v = str(v)
        # Always quote to keep bash 'source' safe (regexes, pipes, spaces, etc.)
        lines.append(f"{k}={_bash_single_quote(v)}")
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text("\n".join(lines) + "\n")

def cfg_load():



    cfg = DEFAULTS.copy()
    raw = read_kv(STACK_CONF)
    # allow either snake_case or legacy keys
    mapping = {
        "tracking_cmd": ["tracking_cmd", "TRACKING_CMD"],
        "server_cmd": ["server_cmd", "SERVER_CMD"],
        "vr_cmd": ["vr_cmd", "VR_CMD"],
        "tracking_ready": ["tracking_ready", "TRACKING_READY"],
        "server_pgrep": ["server_pgrep", "SERVER_PGREP"],
        "vr_pgrep": ["vr_pgrep", "VR_PGREP"],
        "profile": ["profile", "PROFILE"],
        "tracking_enabled": ["tracking_enabled", "TRACKING_ENABLED"],
        "tracking_stop_when_disabled": ["tracking_stop_when_disabled", "TRACK_STOP_WHEN_DISABLED", "TRACKING_STOP_WHEN_DISABLED"],
        "openxr_json": ["openxr_json", "OPENXR_JSON"],
        "xr_runtime": ["xr_runtime", "XR_RUNTIME"],
    }
    for key, aliases in mapping.items():
        for a in aliases:
            if a in raw and raw[a] != "":
                cfg[key] = raw[a]
                break
    return cfg


def cfg_save(cfg: dict):
    # write using lower-case keys
    write_kv(STACK_CONF, cfg)


def state_load():
    if GUI_STATE.exists():
        try:
            return json.loads(GUI_STATE.read_text())
        except Exception:
            return {}
    return {}


def state_save(state: dict):
    GUI_STATE.write_text(json.dumps(state, indent=2, sort_keys=True))


def run_cmd(args, timeout=12):
    try:
        r = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, timeout=timeout)
        return r.returncode, (r.stdout or "").strip()
    except Exception as e:
        return 1, str(e)


def systemctl_user(*args):
    return run_cmd(["systemctl", "--user", *args])

def pgrep_first(pattern: str):
    # Return (pid, cmdline) for first matching process, or None.
    rc, out = run_cmd(["pgrep", "-af", pattern], timeout=2)
    if rc != 0:
        return None
    lines = [ln for ln in out.splitlines() if ln.strip()]
    if not lines:
        return None
    ln = lines[0]
    parts = ln.split(maxsplit=1)
    pid = parts[0]
    cmd = parts[1] if len(parts) > 1 else ""
    return pid, cmd



def pkill_pattern(pattern: str) -> int:
    try:
        r = subprocess.run(["pkill", "-f", pattern], capture_output=True, text=True)
        return r.returncode
    except FileNotFoundError:
        return 127


def stop_stack_components(cfg: dict) -> None:
    # Stop in reverse order so dependencies unwind cleanly.
    vr_pat = cfg.get("vr_pgrep", r"(^|/)(wayvr)(\s|$)")
    srv_pat = cfg.get("server_pgrep", r"wivrn-server")
    trk_pat = cfg.get("tracking_ready", r"slimevr\.jar")

    for pat in (vr_pat, srv_pat, trk_pat):
        pkill_pattern(pat)

def open_in_editor(path: Path):
    editor = os.environ.get("EDITOR")
    if editor:
        subprocess.Popen([editor, str(path)])
        return
    # try common GUI editors, then fall back to xdg-open
    for cmd in ("gedit", "gnome-text-editor", "kate", "mousepad"):
        if shutil_which(cmd):
            subprocess.Popen([cmd, str(path)])
            return
    subprocess.Popen(["xdg-open", str(path)])


def shutil_which(cmd: str):
    for p in os.environ.get("PATH", "").split(os.pathsep):
        c = Path(p) / cmd
        if c.exists() and os.access(c, os.X_OK):
            return str(c)
    return None


def info_dialog(parent, title, body):
    d = Gtk.MessageDialog(parent, 0, Gtk.MessageType.INFO, Gtk.ButtonsType.OK, title)
    d.format_secondary_text(body)
    d.run()
    d.destroy()


def confirm_dialog(parent, title, body):
    d = Gtk.MessageDialog(parent, 0, Gtk.MessageType.QUESTION, Gtk.ButtonsType.OK_CANCEL, title)
    d.format_secondary_text(body)
    rc = d.run()
    d.destroy()
    return rc == Gtk.ResponseType.OK



# --- small UI helpers ---

def markup_escape(text: str) -> str:
    # Escape text for Pango markup.
    try:
        return GLib.markup_escape_text(text)
    except Exception:
        t = text or ""
        return t.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")



def apply_openxr_runtime(json_path: str) -> tuple[bool, str]:
    """Best-effort: set active OpenXR runtime symlink."""
    try:
        jp = Path(json_path)
        if not jp.exists():
            return False, f"Missing runtime JSON: {json_path}"
        dst_dir = Path.home() / ".config" / "openxr" / "1"
        dst_dir.mkdir(parents=True, exist_ok=True)
        dst = dst_dir / "active_runtime.json"
        try:
            if dst.exists() or dst.is_symlink():
                dst.unlink()
        except Exception:
            pass
        dst.symlink_to(jp)
        return True, str(jp)
    except Exception as e:
        return False, str(e)


def detect_steamvr_openxr_json() -> str:
    candidates = [
        "/usr/share/openxr/1/openxr_steamvr.json",
        "/usr/share/openxr/1/openxr_steamvr_linux.json",
        "/usr/share/openxr/1/openxr_steamvr64.json",
        str(Path.home() / '.steam/steam/steamapps/common/SteamVR/steamxr_linux64.json'),
        str(Path.home() / '.local/share/Steam/steamapps/common/SteamVR/steamxr_linux64.json'),
    ]
    for p in candidates:
        try:
            if Path(p).exists():
                return p
        except Exception:
            pass
    return ""


def stop_xrizer() -> tuple[bool, str]:
    # Best-effort: stop XRizer processes so SteamVR can run cleanly.
    # We only kill user processes; no sudo required.
    try:
        r = subprocess.run(['pkill','-f','/opt/xrizer'], capture_output=True, text=True)
        if r.returncode == 0:
            return True, 'XRizer stopped'
        # rc=1 means no processes matched
        return True, 'XRizer not running'
    except FileNotFoundError:
        return False, 'pkill not found'
    except Exception as e:
        return False, str(e)

# --- OpenVR runtime switching (SteamVR <-> XRizer) ---

def detect_steamvr_root() -> str | None:
    candidates = [
        os.path.expanduser("~/.steam/steam/steamapps/common/SteamVR"),
        os.path.expanduser("~/.local/share/Steam/steamapps/common/SteamVR"),
    ]
    for c in candidates:
        if os.path.isdir(c):
            return c
    return None

def detect_vrpathreg() -> str | None:
    # vrpathreg ships with SteamVR
    roots = [detect_steamvr_root()]
    roots = [r for r in roots if r]
    for root in roots:
        cand = os.path.join(root, "bin", "linux64", "vrpathreg")
        if os.path.isfile(cand) and os.access(cand, os.X_OK):
            return cand
    # fallback if it's already in PATH
    return shutil.which("vrpathreg")

def set_openvr_runtime(runtime_dir: str) -> tuple[bool, str]:
    vrpathreg = detect_vrpathreg()
    if not vrpathreg:
        return False, "vrpathreg not found (SteamVR not installed?)"

    try:
        r = subprocess.run([vrpathreg, "setruntime", runtime_dir], capture_output=True, text=True)
        ok = (r.returncode == 0)
        out = (r.stdout or "").strip()
        err = (r.stderr or "").strip()
        blob = "\n".join([x for x in [out, err] if x])
        if ok:
            return True, f"OpenVR runtime set to: {runtime_dir}"
        return False, f"Failed to set OpenVR runtime: {blob or 'unknown error'}"
    except Exception as e:
        return False, f"Failed to set OpenVR runtime: {e}"

def ensure_openvr_xrizer_enabled() -> tuple[bool, str]:
    if os.path.isdir("/opt/xrizer"):
        return set_openvr_runtime("/opt/xrizer")
    return False, "XRizer not installed (/opt/xrizer missing)"

def ensure_openvr_steamvr_enabled() -> tuple[bool, str]:
    root = detect_steamvr_root()
    if root:
        return set_openvr_runtime(root)
    return False, "SteamVR runtime folder not found"

def cmd_display_name(cmd: str, fallback: str) -> str:
    # Friendly name for a command: basename of first token.
    cmd = (cmd or "").strip()
    if not cmd:
        return fallback
    try:
        parts = shlex.split(cmd)
    except Exception:
        parts = cmd.split()
    if not parts:
        return fallback
    exe = (parts[0] or "").strip()
    base = os.path.basename(exe)
    return base or fallback

class VRControlApp(Gtk.Window):
    def __init__(self):
        super().__init__(title=f"VR Stack Control {APP_VERSION}")
        ensure_dirs()

        self.cfg = cfg_load()
        self.state = state_load()

        self.set_default_size(920, 560)
        self.set_border_width(10)

        root = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        self.add(root)

        self.stack = Gtk.Stack()
        self.stack.set_transition_type(Gtk.StackTransitionType.SLIDE_LEFT_RIGHT)
        self.stack.set_transition_duration(180)

        sidebar = Gtk.StackSidebar()
        sidebar.set_stack(self.stack)
        sidebar.set_size_request(200, -1)

        # Left: sidebar (tabs). Right: quick controls + page content.
        root.pack_start(sidebar, False, False, 0)

        right = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        right.set_hexpand(True)
        right.set_vexpand(True)
        root.pack_start(right, True, True, 0)

        self.quickbar = self.build_quick_controls()
        right.pack_start(self.quickbar, False, False, 0)
        right.pack_start(self.stack, True, True, 0)

        self.status_view = self.build_status_view()
        self.apps_view = self.build_apps_view()
        self.profiles_view = self.build_profiles_view()
        self.debug_view = self.build_debug_view()

        self.stack.add_titled(self.status_view, "status", "Status")
        self.stack.add_titled(self.apps_view, "apps", "Apps & Settings")
        self.stack.add_titled(self.profiles_view, "profiles", "Profiles")
        self.stack.add_titled(self.debug_view, "debug", "Debug")

        # Live status: keep it fresh automatically so the running-app list
        # and indicator lights update without needing manual clicks.
        self._alive = True
        self.connect("destroy", self.on_destroy)
        self.refresh_status()

        # GUI-scoped autostart: if enabled, start the stack when this window opens.
        try:
            if bool(self.state.get('autostart_on_open', False)):
                systemctl_user('start', STACK_SERVICE)
        except Exception:
            pass
        GLib.timeout_add_seconds(2, self._auto_refresh)

        self.show_all()

        # Update labels that depend on the current command names.
        self.update_display_names()


    def update_display_names(self) -> None:
        """Update UI labels to reflect the configured command names."""
        try:
            self.name_tracking = cmd_display_name(self.cfg.get("tracking_cmd", ""), "Tracking")
            self.name_server = cmd_display_name(self.cfg.get("server_cmd", ""), "Server")
            self.name_vr = cmd_display_name(self.cfg.get("vr_cmd", ""), "VR App")

            if getattr(self, "lbl_tracking_name", None) is not None:
                self.lbl_tracking_name.set_text(f"Tracking ({self.name_tracking})")
            if getattr(self, "lbl_server_name", None) is not None:
                self.lbl_server_name.set_text(f"Server ({self.name_server})")
            if getattr(self, "lbl_vr_name", None) is not None:
                self.lbl_vr_name.set_text(f"VR App ({self.name_vr})")

            if getattr(self, "lbl_order_note", None) is not None:
                self.lbl_order_note.set_text(
                    f"Expected order: Tracking ‚Üí Server ‚Üí VR App  ( {self.name_tracking} ‚Üí {self.name_server} ‚Üí {self.name_vr} )"
                )
        except Exception:
            # Never crash the app because labels are missing.
            pass

    def on_destroy(self, *_args):
        self._alive = False

    def _auto_refresh(self):
        """Periodic UI refresh (runs on the GTK main loop)."""
        if not getattr(self, "_alive", False):
            return False
        try:
            self.refresh_status()
        except Exception:
            # Never crash the whole app because a refresh query failed.
            pass
        return True






    def toast(self, msg: str, seconds: int = 4):
        """Lightweight status message without popups.

        We temporarily append the message to the window title, then restore.
        """
        try:
            base = f"VR Stack Control {APP_VERSION}"
            self.set_title(f"{base} ‚Äî {msg}")

            def _restore():
                try:
                    self.set_title(base)
                except Exception:
                    pass
                return False

            GLib.timeout_add_seconds(max(1, int(seconds)), _restore)
        except Exception:
            pass

    # ---------------------------------------------------------------------
    # Logging / helpers (best-effort; never crash the GUI)
    # ---------------------------------------------------------------------
    def debug_log(self, msg: str):
        try:
            if hasattr(self, "debug_buffer") and self.debug_buffer is not None:
                end = self.debug_buffer.get_end_iter()
                self.debug_buffer.insert(end, msg + "\n")
            else:
                print(msg)
        except Exception:
            try:
                print(msg)
            except Exception:
                pass

    def find_steamvr_openxr_json(self) -> str:
        """Locate SteamVR's OpenXR runtime JSON (steamxr_linux64.json)."""
        candidates = []
        home = os.path.expanduser("~")
        candidates += [
            os.path.join(home, ".steam/steam/steamapps/common/SteamVR/steamxr_linux64.json"),
            os.path.join(home, ".local/share/Steam/steamapps/common/SteamVR/steamxr_linux64.json"),
            os.path.join(home, ".steam/root/steamapps/common/SteamVR/steamxr_linux64.json"),
        ]

        vdf_paths = [
            os.path.join(home, ".steam/steam/steamapps/libraryfolders.vdf"),
            os.path.join(home, ".local/share/Steam/steamapps/libraryfolders.vdf"),
            os.path.join(home, ".steam/root/steamapps/libraryfolders.vdf"),
        ]
        for vdf in vdf_paths:
            try:
                if not os.path.exists(vdf):
                    continue
                data = open(vdf, "r", errors="ignore").read()
                for p in re.findall(r'"path"\s+"([^"]+)"', data):
                    p = p.replace('\\\\', '\\')
                    candidates.append(os.path.join(p, "steamapps/common/SteamVR/steamxr_linux64.json"))
                for p in re.findall(r'"\\d+"\s+"([^"]+)"', data):
                    if "/" in p or "\\\\" in p:
                        p = p.replace('\\\\', '\\')
                        candidates.append(os.path.join(p, "steamapps/common/SteamVR/steamxr_linux64.json"))
            except Exception:
                pass

        for c in candidates:
            try:
                if c and os.path.isfile(c):
                    return c
            except Exception:
                pass
        return ""



    def update_detected_paths(self):
        """Update detected path fields + status badges."""
        try:
            # Active OpenXR runtime (resolved symlink/target)
            active = Path("~/.config/openxr/1/active_runtime.json").expanduser()
            active_txt = str(active.resolve()) if active.exists() else ""

            # WiVRn OpenXR JSON (system)
            wivrn_json = Path("/usr/share/openxr/1/openxr_wivrn.json")
            wivrn_txt = str(wivrn_json) if wivrn_json.exists() else ""

            # SteamVR OpenXR JSON (auto-detect + override)
            steamvr_openxr = self.cfg.get("override_steamvr_openxr_json") or self.find_steamvr_openxr_json()
            steamvr_openxr_txt = steamvr_openxr or ""

            # SteamVR root (derive from SteamVR OpenXR json if possible + override)
            steamvr_root = self.cfg.get("override_steamvr_root")
            if not steamvr_root and steamvr_openxr_txt:
                try:
                    steamvr_root = str(Path(steamvr_openxr_txt).expanduser().parent)
                except Exception:
                    steamvr_root = ""
            steamvr_root_txt = steamvr_root or ""

            # XRizer root (override or /opt/xrizer if present)
            xrizer_root = self.cfg.get("override_xrizer_root") or ("/opt/xrizer" if Path("/opt/xrizer").is_dir() else "")
            xrizer_txt = xrizer_root or ""

            # openvrpaths.vrpath (canonical + common Steam locations + override)
            openvrpaths = self.cfg.get("override_openvrpaths")
            if not openvrpaths:
                candidates = [
                    Path("~/.config/openvr/openvrpaths.vrpath").expanduser(),
                    Path("~/.local/share/Steam/config/openvrpaths.vrpath").expanduser(),
                    Path("~/.steam/steam/config/openvrpaths.vrpath").expanduser(),
                    Path("~/.steam/root/config/openvrpaths.vrpath").expanduser(),
                ]
                # Prefer real files first
                for c in candidates:
                    if c.is_file():
                        openvrpaths = str(c)
                        break
                # If we only have a symlink (even dangling), show it so the user can repair it
                if not openvrpaths:
                    for c in candidates:
                        if c.is_symlink():
                            openvrpaths = str(c)
                            break
            openvrpaths_txt = openvrpaths or ""

            # Write entries
            self.entry_path_openxr_active.set_text(active_txt)
            self.entry_path_openxr_wivrn.set_text(wivrn_txt)
            self.entry_path_openxr_steamvr.set_text(steamvr_openxr_txt)
            self.entry_path_steamvr_root.set_text(steamvr_root_txt)
            self.entry_path_xrizer.set_text(xrizer_txt)
            self.entry_path_openvrpaths.set_text(openvrpaths_txt)

            # Status badges (‚úî / ‚ö† / ‚ùå)
            self.lbl_path_openxr_active.set_text(self._status_for_path(active_txt, "file"))
            self.lbl_path_openxr_wivrn.set_text(self._status_for_path(wivrn_txt, "file"))
            self.lbl_path_openxr_steamvr.set_text(self._status_for_path(steamvr_openxr_txt, "file"))
            self.lbl_path_steamvr_root.set_text(self._status_for_path(steamvr_root_txt, "dir"))
            self.lbl_path_xrizer.set_text(self._status_for_path(xrizer_txt, "dir"))
            self.lbl_path_openvrpaths.set_text(self._status_for_path(openvrpaths_txt, "file"))

        except Exception as e:
            self.debug_log("update_detected_paths failed: " + repr(e))
    def build_quick_controls(self):
        _toggle = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        _toggle.set_margin_bottom(4)

        title = Gtk.Label(xalign=0)
        title.set_markup("<b>Stack control</b>")
        _toggle.pack_start(title, False, False, 0)

        self.lbl_quick_state = Gtk.Label(xalign=0)
        self.lbl_quick_state.set_text("üî¥ Stopped")
        _toggle.pack_start(self.lbl_quick_state, False, False, 0)

        _toggle.pack_start(Gtk.Separator(orientation=Gtk.Orientation.VERTICAL), False, False, 6)

        self.btn_quick_start = Gtk.Button(label="Start")
        self.btn_quick_stop = Gtk.Button(label="Stop")
        self.btn_quick_start.connect("clicked", lambda *_: self.on_quick_start())
        self.btn_quick_stop.connect("clicked", lambda *_: self.on_quick_stop())
        _toggle.pack_start(self.btn_quick_start, False, False, 0)
        _toggle.pack_start(self.btn_quick_stop, False, False, 0)

        self.btn_quick_autostart = Gtk.ToggleButton(label="Autostart")
        self.btn_quick_autostart.set_tooltip_text("Start VR stack automatically when this control panel opens (not on boot)")
        self.btn_quick_autostart.connect("toggled", lambda *_: self.on_quick_autostart_toggled())
        _toggle.pack_start(self.btn_quick_autostart, False, False, 0)


        _toggle.pack_start(Gtk.Separator(orientation=Gtk.Orientation.VERTICAL), False, False, 6)

        rt_lbl = Gtk.Label(xalign=0)
        rt_lbl.set_markup("<b>XR Runtime</b>")
        _toggle.pack_start(rt_lbl, False, False, 0)

        self.combo_runtime = Gtk.ComboBoxText()
        self.combo_runtime.append("wivrn", "WiVRn")
        self.combo_runtime.append("steamvr", "SteamVR")
        _toggle.pack_start(self.combo_runtime, False, False, 0)

        cur = (self.cfg.get("xr_runtime", "wivrn") or "wivrn").strip().lower()
        # If config was edited manually, infer from openxr_json too
        oj = (self.cfg.get("openxr_json") or "").lower()
        if "steamvr" in oj:
            cur = "steamvr"
        if cur not in ("wivrn", "steamvr"):
            cur = "wivrn"
        self.combo_runtime.set_active_id(cur)
        self.combo_runtime.connect("changed", lambda *_: self.on_runtime_changed())

        # Beginner-friendly hint
        hint = Gtk.Label(xalign=0)
        hint.set_line_wrap(True)
        hint.set_max_width_chars(70)
        hint.set_markup(
            "<span size='small' foreground='#777'>"
            "Starts/stops the VR stack in order: Tracking ‚Üí Server ‚Üí VR App (systemd --user)."
            "</span>"
        )

        wrap = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        wrap.pack_start(_toggle, False, False, 0)
        wrap.pack_start(hint, False, False, 0)
        return wrap

    def update_quick_controls(self, svc_active: bool):
        if svc_active:
            self.lbl_quick_state.set_text("üü¢ Running")
            self.btn_quick_start.set_sensitive(False)
            self.btn_quick_stop.set_sensitive(True)
        else:
            self.lbl_quick_state.set_text("üî¥ Stopped")
            self.btn_quick_start.set_sensitive(True)
            self.btn_quick_stop.set_sensitive(False)

    def on_quick_start(self):
        # Ensure OpenXR runtime matches config
        try:
            oj = (self.cfg.get("openxr_json") or "").strip()
            if oj:
                apply_openxr_runtime(oj)
        except Exception:
            pass

        # systemctl_user() returns (rc:int, combined_output:str)
        rc, out = systemctl_user("start", STACK_SERVICE)
        if rc == 0:
            self.toast("Starting‚Ä¶")
        else:
            # systemd sends errors on stderr, but we capture combined output.
            msg = out.strip() or "unknown error"
            self.toast(f"Start failed: {msg}")
        self.refresh_status()

    def on_quick_stop(self):
        # Stop should always stop the actual processes, even if the systemd unit is oneshot.
        rc, out = systemctl_user("stop", STACK_SERVICE)
        stop_stack_components(self.cfg)

        if rc == 0:
            self.toast("Stopping‚Ä¶")
        else:
            msg = out.strip() or "unknown error"
            self.toast(f"Stop requested (systemd said: {msg}).")
        self.refresh_status()

    def on_quick_autostart_toggled(self):
        # Avoid recursion when refresh_status updates the toggle.
        if getattr(self, '_updating_autostart', False):
            return
        enable = bool(self.btn_quick_autostart.get_active())
        # GUI-scoped autostart: we do NOT systemctl enable/disable.
        self.state['autostart_on_open'] = enable
        state_save(self.state)
        if enable:
            # Start immediately on toggle-on (best effort).
            rc, out = systemctl_user('start', STACK_SERVICE)
            self.toast('Autostart on open enabled (starting now)‚Ä¶' if rc == 0 else f'Start failed: {out}')
        else:
            self.toast('Autostart on open disabled')
        self.refresh_status()


    def on_runtime_changed(self):
        try:
            choice = self.combo_runtime.get_active_id() or "wivrn"
        except Exception:
            choice = "wivrn"
        choice = (choice or "wivrn").strip().lower()

        if choice == "steamvr":
            steam_json = (self.cfg.get("override_steamvr_openxr_json") or "").strip() or detect_steamvr_openxr_json()
            if not steam_json:
                self.toast("SteamVR OpenXR runtime JSON not found. Install SteamVR first.")
                try:
                    self.combo_runtime.set_active_id("wivrn")
                except Exception:
                    pass
                return
            self.cfg["xr_runtime"] = "steamvr"
            self.cfg["openxr_json"] = steam_json
            ok, msg = apply_openxr_runtime(steam_json)
            # Stop XRizer if present (it can hijack SteamVR startup)
            sx_ok, sx_msg = stop_xrizer()
            ov_ok, ov_msg = ensure_openvr_steamvr_enabled()
            if ok:
                self.toast(f"OpenXR runtime set to SteamVR. {sx_msg} (OpenVR: {ov_msg})")
            else:
                self.toast(f"Failed to set SteamVR runtime: {msg}")
                return
        else:
            wivrn_json = "/usr/share/openxr/1/openxr_wivrn.json"
            self.cfg["xr_runtime"] = "wivrn"
            self.cfg["openxr_json"] = wivrn_json
            ok, msg = apply_openxr_runtime(wivrn_json)
            ov_ok, ov_msg = ensure_openvr_xrizer_enabled()
            if ok:
                self.toast(f"OpenXR runtime set to WiVRn (OpenVR: {ov_msg})")
            else:
                self.toast(f"Failed to set WiVRn runtime: {msg}")
                return
        try:
            cfg_save(self.cfg)
        except Exception as e:
            self.toast(f"Failed to save config: {e}")
            return

        # Reload from disk to ensure the selection sticks
        try:
            self.cfg = cfg_load()
            cur = (self.cfg.get('xr_runtime', 'wivrn') or 'wivrn').strip().lower()
            if cur not in ('wivrn','steamvr'):
                cur = 'wivrn'
            # keep UI consistent
            self.combo_runtime.set_active_id(cur)
        except Exception:
            pass


    # ---------------- Status ----------------
    def build_status_view(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)

        header = self.section_header("Live status")
        box.pack_start(header, False, False, 0)

        grid = Gtk.Grid(column_spacing=10, row_spacing=8)
        box.pack_start(grid, False, False, 0)

        self.lbl_service = Gtk.Label(xalign=0)
        self.lbl_autostart = Gtk.Label(xalign=0)
        self.lbl_profile = Gtk.Label(xalign=0)

        self._grid_row(grid, 0, "Stack service:", self.lbl_service)
        self._grid_row(grid, 1, "Start on app open:", self.lbl_autostart)
        self._grid_row(grid, 2, "Active profile:", self.lbl_profile)

        btn_row = Gtk.Box(spacing=10)
        box.pack_start(btn_row, False, False, 0)

        btn_refresh = Gtk.Button(label="Refresh")
        btn_refresh.set_image(Gtk.Image.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON))
        btn_refresh.set_always_show_image(True)
        btn_refresh.connect("clicked", lambda *_: self.refresh_status())

        btn_row.pack_start(btn_refresh, False, False, 0)

        # Stack processes (live)
        proc_header = self.section_header("Running apps (detected)")
        box.pack_start(proc_header, False, False, 0)

        proc_grid = Gtk.Grid(column_spacing=12, row_spacing=8)
        proc_grid.set_hexpand(True)

        # column headers
        h1 = self.small_muted("Component")
        h2 = self.small_muted("Expected order")
        h3 = self.small_muted("Detected right now")
        proc_grid.attach(h1, 0, 0, 1, 1)
        proc_grid.attach(h2, 1, 0, 1, 1)
        proc_grid.attach(h3, 2, 0, 1, 1)

        self.lbl_tracking_proc = self.value_label("‚Ä¶")
        self.lbl_server_proc = self.value_label("‚Ä¶")
        self.lbl_vr_proc = self.value_label("‚Ä¶")

        self.lbl_tracking_name = self.small_muted("Tracking")
        proc_grid.attach(self.lbl_tracking_name, 0, 1, 1, 1)
        proc_grid.attach(self.small_muted("1"), 1, 1, 1, 1)
        proc_grid.attach(self.lbl_tracking_proc, 2, 1, 1, 1)

        self.lbl_server_name = self.small_muted("Server")
        proc_grid.attach(self.lbl_server_name, 0, 2, 1, 1)
        proc_grid.attach(self.small_muted("2"), 1, 2, 1, 1)
        proc_grid.attach(self.lbl_server_proc, 2, 2, 1, 1)

        self.lbl_vr_name = self.small_muted("VR App")
        proc_grid.attach(self.lbl_vr_name, 0, 3, 1, 1)
        proc_grid.attach(self.small_muted("3"), 1, 3, 1, 1)
        proc_grid.attach(self.lbl_vr_proc, 2, 3, 1, 1)

        self.lbl_order_note = self.small_muted("")
        self.lbl_order_note.set_line_wrap(True)
        proc_grid.attach(self.lbl_order_note, 0, 4, 3, 1)

        box.pack_start(proc_grid, False, False, 0)

        hint = Gtk.Label(xalign=0)
        hint.set_line_wrap(True)
        hint.set_text(
            "Tip: If the stack won't start from the desktop, check that your OpenXR runtime is set correctly and that tracking app/VR streaming server/VR app commands exist."
        )
        box.pack_start(hint, False, False, 0)

        return self.wrap_scroller(box)

    def refresh_status(self):
        rc, s = systemctl_user("is-active", "vr-stack-control.service")
        svc_active = (rc == 0 and s == "active")
        self.lbl_service.set_text("RUNNING" if svc_active else "STOPPED")
        # GUI-scoped autostart (starts the stack when this app opens)
        auto_on_open = bool(self.state.get('autostart_on_open', False))
        self.lbl_autostart.set_text('ON APP OPEN' if auto_on_open else 'OFF')

        # Keep the quickbar toggle in sync
        try:
            self._updating_autostart = True
            if hasattr(self, 'btn_quick_autostart'):
                self.btn_quick_autostart.set_active(auto_on_open)
        finally:
            self._updating_autostart = False

        self.lbl_profile.set_text(self.cfg.get("profile", "default"))


        t = s = v = None
        # Live process detection (best-effort)
        try:
            tracking_pat = self.cfg.get("tracking_ready") or self.name_tracking
            server_pat = self.cfg.get("server_pgrep") or self.name_server
            vr_pat = self.cfg.get("vr_pgrep") or self.name_vr

            t = pgrep_first(tracking_pat)
            s = pgrep_first(server_pat)
            v = pgrep_first(vr_pat)

            def fmt(x):
                if not x:
                    return "Not detected"
                pid, cmd = x
                # keep it short
                short = cmd
                if len(short) > 80:
                    short = short[:77] + "..."
                return f"PID {pid}: {short}"

            if hasattr(self, "lbl_tracking_proc"):
                self.lbl_tracking_proc.set_text(fmt(t))
            if hasattr(self, "lbl_server_proc"):
                self.lbl_server_proc.set_text(fmt(s))
            if hasattr(self, "lbl_vr_proc"):
                self.lbl_vr_proc.set_text(fmt(v))

            note = ""
            if v and not s:
                note = f"‚ö† {self.name_vr} is running but {self.name_server} was not detected. Usually you want the server running before the VR app."
            elif s and not t:
                note = f"‚ö† {self.name_server} is running but {self.name_tracking} was not detected. Usually you start tracking first."
            elif (t and s and v):
                note = "‚úì All three parts are running. Expected order is 1‚Üí2‚Üí3."
            else:
                note = ""

            if hasattr(self, "lbl_order_note"):
                self.lbl_order_note.set_text(note)
        except Exception:
            # Don't break the UI if pgrep is missing or patterns are invalid
            if hasattr(self, "lbl_order_note"):
                self.lbl_order_note.set_text("")

        stack_running = svc_active or bool(t or s or v)
        self.stack_running = stack_running
        self.update_quick_controls(stack_running)

        self.last_refresh = time.time()
        return True

    # ---------------- Apps & Settings ----------------
    def build_apps_view(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)

        box.pack_start(self.section_header("What gets launched"), False, False, 0)

        grid = Gtk.Grid(column_spacing=10, row_spacing=8)
        box.pack_start(grid, False, False, 0)

        self.entry_tracking_cmd = Gtk.Entry()
        self.entry_server_cmd = Gtk.Entry()
        self.entry_vr_cmd = Gtk.Entry()
        self.entry_tracking_ready = Gtk.Entry()
        self.entry_server_pgrep = Gtk.Entry()
        self.entry_vr_pgrep = Gtk.Entry()

        self.entry_tracking_cmd.set_text(self.cfg["tracking_cmd"])
        self.entry_server_cmd.set_text(self.cfg["server_cmd"])
        self.entry_vr_cmd.set_text(self.cfg["vr_cmd"])
        self.entry_tracking_ready.set_text(self.cfg["tracking_ready"])
        self.entry_server_pgrep.set_text(self.cfg["server_pgrep"])
        self.entry_vr_pgrep.set_text(self.cfg["vr_pgrep"])

        # Tracking ON/OFF
        self.switch_tracking_enabled = Gtk.Switch()
        self.switch_tracking_enabled.set_active(str(self.cfg.get('tracking_enabled','true')).lower() in ('1','true','yes','on'))

        r = 0
        r = self._grid_row_switch(grid, r, "Tracking enabled", self.switch_tracking_enabled,
                                 "Turn OFF to start the stack without tracking software (e.g. no full-body tracking).")
        r = self._grid_entry(grid, r, "Tracking command", self.entry_tracking_cmd,
                             "Started first. Your tracking software (binary, script, or AppImage).")
        r = self._grid_entry(grid, r, "Tracking ready pattern", self.entry_tracking_ready,
                             "We wait for this to appear in process list before starting VR streaming server.")
        r = self._grid_entry(grid, r, "Server command", self.entry_server_cmd,
                             "Started second. Your VR streaming server.")
        r = self._grid_entry(grid, r, "Server pgrep pattern", self.entry_server_pgrep,
                             "Used to detect if the server is already running (avoid duplicates).")
        r = self._grid_entry(grid, r, "VR app command", self.entry_vr_cmd,
                             "Started last. Your PC VR app (OpenXR).")
        r = self._grid_entry(grid, r, "VR app pgrep pattern", self.entry_vr_pgrep,
                             "Used to detect if your VR app is already running.")

        btn_row = Gtk.Box(spacing=10)
        box.pack_start(btn_row, False, False, 0)

        btn_save = Gtk.Button(label="Save settings")
        btn_save.set_image(Gtk.Image.new_from_icon_name("document-save", Gtk.IconSize.BUTTON))
        btn_save.set_always_show_image(True)
        btn_save.connect("clicked", lambda *_: self.on_save_settings())

        btn_defaults = Gtk.Button(label="Reset to defaults")
        btn_defaults.set_image(Gtk.Image.new_from_icon_name("edit-undo", Gtk.IconSize.BUTTON))
        btn_defaults.set_always_show_image(True)
        btn_defaults.connect("clicked", lambda *_: self.on_reset_defaults())

        btn_row.pack_start(btn_save, False, False, 0)
        btn_row.pack_start(btn_defaults, False, False, 0)

        help_block = Gtk.Label(xalign=0)
        help_block.set_line_wrap(True)
        help_block.set_text(
            "Why this matters: these settings are exactly what your start script / systemd service launches. "
            "If a command is wrong, the stack will fail or start the wrong thing. The pgrep patterns prevent duplicate launches."
        )
        box.pack_start(help_block, False, False, 0)

        # Detected runtime / helper paths (read-only)
        box.pack_start(Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL), False, False, 6)

        box.pack_start(self.section_header("Detected paths"), False, False, 0)
        dgrid = Gtk.Grid(column_spacing=10, row_spacing=8)
        box.pack_start(dgrid, False, False, 0)

        # Entry widgets
        # Active runtime and WiVRn are informational (read-only). Others are editable overrides (type or Browse‚Ä¶).
        self.entry_path_openxr_active = Gtk.Entry(); self._make_ro(self.entry_path_openxr_active)
        self.entry_path_openxr_wivrn  = Gtk.Entry(); self._make_ro(self.entry_path_openxr_wivrn)

        self.entry_path_openxr_steamvr = Gtk.Entry()
        self.entry_path_steamvr_root = Gtk.Entry()
        self.entry_path_xrizer = Gtk.Entry()
        self.entry_path_openvrpaths = Gtk.Entry()

        # Allow typing overrides directly
        self._bind_entry_override(self.entry_path_openxr_steamvr, "override_steamvr_openxr_json")
        self._bind_entry_override(self.entry_path_steamvr_root, "override_steamvr_root")
        self._bind_entry_override(self.entry_path_xrizer, "override_xrizer_root")
        self._bind_entry_override(self.entry_path_openvrpaths, "override_openvrpaths")

        # Status labels
        self.lbl_path_openxr_active = Gtk.Label(xalign=0)
        self.lbl_path_openxr_wivrn = Gtk.Label(xalign=0)
        self.lbl_path_openxr_steamvr = Gtk.Label(xalign=0)
        self.lbl_path_steamvr_root = Gtk.Label(xalign=0)
        self.lbl_path_xrizer = Gtk.Label(xalign=0)
        self.lbl_path_openvrpaths = Gtk.Label(xalign=0)

        dr = 0
        dr = self._grid_path(dgrid, dr, "Active OpenXR runtime", self.entry_path_openxr_active, self.lbl_path_openxr_active, None,
                             "Resolved target of ~/.config/openxr/1/active_runtime.json")
        dr = self._grid_path(dgrid, dr, "WiVRn OpenXR JSON", self.entry_path_openxr_wivrn, self.lbl_path_openxr_wivrn, None,
                             "/usr/share/openxr/1/openxr_wivrn.json")
        dr = self._grid_path(dgrid, dr, "SteamVR OpenXR JSON", self.entry_path_openxr_steamvr, self.lbl_path_openxr_steamvr,
                             ("file","override_steamvr_openxr_json"),
                             "SteamVR OpenXR runtime file (steamxr_linux64.json)")
        dr = self._grid_path(dgrid, dr, "SteamVR OpenVR root", self.entry_path_steamvr_root, self.lbl_path_steamvr_root,
                             ("dir","override_steamvr_root"),
                             "SteamVR runtime directory (contains bin/ and drivers/)")
        dr = self._grid_path(dgrid, dr, "XRizer root", self.entry_path_xrizer, self.lbl_path_xrizer,
                             ("dir","override_xrizer_root"),
                             "OpenVR‚ÜíOpenXR bridge directory (used only when enabled)")
        dr = self._grid_path(dgrid, dr, "openvrpaths.vrpath", self.entry_path_openvrpaths, self.lbl_path_openvrpaths,
                             ("file","override_openvrpaths"),
                             "OpenVR paths file (Steam config).")

        btn_row2 = Gtk.Box(spacing=10)

        btn_paths = Gtk.Button(label="Refresh detected paths")
        btn_paths.connect("clicked", lambda *_: self.update_detected_paths())

        btn_repair = Gtk.Button(label="Repair openvrpaths.vrpath")
        btn_repair.set_tooltip_text("Recreate ~/.config/openvr/openvrpaths.vrpath and symlink Steam config files to it.")
        btn_repair.connect("clicked", lambda *_: self.repair_openvrpaths())

        btn_row2.pack_start(btn_paths, False, False, 0)
        btn_row2.pack_start(btn_repair, False, False, 0)
        box.pack_start(btn_row2, False, False, 0)

        # Fill on first open
        self.update_detected_paths()

        return self.wrap_scroller(box)

    def on_save_settings(self):
        self.cfg["tracking_enabled"] = 'true' if self.switch_tracking_enabled.get_active() else 'false'
        # keep compatibility with the runner; we don't expose this in UI
        self.cfg["tracking_stop_when_disabled"] = 'true'
        self.cfg["tracking_cmd"] = self.entry_tracking_cmd.get_text().strip()
        self.cfg["server_cmd"] = self.entry_server_cmd.get_text().strip()
        self.cfg["vr_cmd"] = self.entry_vr_cmd.get_text().strip()
        self.cfg["tracking_ready"] = self.entry_tracking_ready.get_text().strip()
        self.cfg["server_pgrep"] = self.entry_server_pgrep.get_text().strip()
        self.cfg["vr_pgrep"] = self.entry_vr_pgrep.get_text().strip()
        cfg_save(self.cfg)
        info_dialog(self, "Saved", f"Saved to {STACK_CONF}")
        self.refresh_status()

    def on_reset_defaults(self):
        if not confirm_dialog(self, "Reset to defaults?", "This will overwrite your current commands and patterns."):
            return
        for k, v in DEFAULTS.items():
            self.cfg[k] = v
        self.entry_tracking_cmd.set_text(self.cfg["tracking_cmd"])
        self.entry_server_cmd.set_text(self.cfg["server_cmd"])
        self.entry_vr_cmd.set_text(self.cfg["vr_cmd"])
        self.entry_tracking_ready.set_text(self.cfg["tracking_ready"])
        self.entry_server_pgrep.set_text(self.cfg["server_pgrep"])
        self.entry_vr_pgrep.set_text(self.cfg["vr_pgrep"])
        cfg_save(self.cfg)
        info_dialog(self, "Reset", "Defaults restored.")
        self.refresh_status()

    # ---------------- Actions ----------------
    def build_actions_view(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)

        box.pack_start(self.section_header("One-click actions"), False, False, 0)

        grid = Gtk.Grid(column_spacing=10, row_spacing=8)
        box.pack_start(grid, False, False, 0)

        # Stack + tray
        self.combo_stack = Gtk.ComboBoxText()
        for k, label in (
            ("none", "Do nothing"),
            ("start", "Start stack"),
            ("restart", "Restart stack"),
            ("stop", "Stop stack"),
            ("enable", "Enable autostart"),
            ("disable", "Disable autostart"),
        ):
            self.combo_stack.append(k, label)

        # App settings actions (these are "safe" UI actions)
        self.combo_tracking = Gtk.ComboBoxText()
        self.combo_server = Gtk.ComboBoxText()
        self.combo_vr = Gtk.ComboBoxText()
        self.combo_patterns = Gtk.ComboBoxText()

        for combo in (self.combo_tracking, self.combo_server, self.combo_vr, self.combo_patterns):
            combo.append("none", "Do nothing")
            combo.append("edit", "Edit settings (jump to Apps & Settings)")
            combo.append("reset", "Reset to defaults")

        # restore last selections
        self._combo_set(self.combo_stack, self.state.get("action_stack", "none"))
        self._combo_set(self.combo_tracking, self.state.get("action_tracking", "none"))
        self._combo_set(self.combo_server, self.state.get("action_server", "none"))
        self._combo_set(self.combo_vr, self.state.get("action_vr", "none"))
        self._combo_set(self.combo_patterns, self.state.get("action_patterns", "none"))

        for name, combo in (
            ("action_stack", self.combo_stack),
            ("action_tracking", self.combo_tracking),
            ("action_server", self.combo_server),
            ("action_vr", self.combo_vr),
            ("action_patterns", self.combo_patterns),
        ):
            combo.connect("changed", lambda c, n=name: self.on_combo_changed(n, c))

        r = 0
        r = self._grid_row_combo(grid, r, "VR stack", self.combo_stack, "Start/stop the VR stack service (launches tracking app ‚Üí VR streaming server ‚Üí VR app in order).")
        r = self._grid_row_combo(grid, r, "Tracking settings", self.combo_tracking, "Tracking app settings (usually tracking app). Change this if you moved/renamed the tracking app AppImage or want a different tracker app.")
        r = self._grid_row_combo(grid, r, "Server settings", self.combo_server, "VR streaming server server settings (streams VR to your Quest). Change only if you installed VR streaming server somewhere unusual.")
        r = self._grid_row_combo(grid, r, "VR app settings", self.combo_vr, "VR app settings (usually VR app). This is the app that opens on your PC and uses OpenXR.")
        r = self._grid_row_combo(grid, r, "Patterns", self.combo_patterns, "How the app checks what is running (advanced). Leave this alone unless detection is wrong.")

        btn_row = Gtk.Box(spacing=10)
        box.pack_start(btn_row, False, False, 0)

        btn_apply = Gtk.Button(label="Apply")
        btn_apply.set_image(Gtk.Image.new_from_icon_name("system-run", Gtk.IconSize.BUTTON))
        btn_apply.set_always_show_image(True)
        btn_apply.connect("clicked", lambda *_: self.on_apply_actions())

        btn_row.pack_start(btn_apply, False, False, 0)

        hint = Gtk.Label(xalign=0)
        hint.set_line_wrap(True)
        hint.set_text(
            "Selections are saved automatically. If you close and reopen the GUI, your dropdown choices will still be set."
        )
        box.pack_start(hint, False, False, 0)

        return self.wrap_scroller(box)

    def on_combo_changed(self, key, combo: Gtk.ComboBoxText):
        self.state[key] = combo.get_active_id() or "none"
        state_save(self.state)

    def on_apply_actions(self):
        choices = {
            "Stack": self.combo_stack.get_active_text(),
            "Tracking": self.combo_tracking.get_active_text(),
            "Server": self.combo_server.get_active_text(),
            "VR app": self.combo_vr.get_active_text(),
            "Patterns": self.combo_patterns.get_active_text(),
        }
        summary = "\n".join([f"{k}: {v}" for k, v in choices.items()])
        if not confirm_dialog(self, "Apply these actions?", summary):
            return

        # stack + tray actions (systemd)
        self.apply_systemd_action("vr-stack-control.service", self.combo_stack.get_active_id())
        
        # app settings actions
        self.apply_settings_action(self.combo_tracking.get_active_id(), scope="tracking")
        self.apply_settings_action(self.combo_server.get_active_id(), scope="server")
        self.apply_settings_action(self.combo_vr.get_active_id(), scope="vr")
        self.apply_settings_action(self.combo_patterns.get_active_id(), scope="patterns")

        self.refresh_status()
        info_dialog(self, "Done", "Actions applied.")

    def apply_systemd_action(self, unit: str, action: str):
        if action in (None, "none"):
            return
        if action == "start":
            systemctl_user("start", unit)
        elif action == "stop":
            systemctl_user("stop", unit)
        elif action == "restart":
            systemctl_user("restart", unit)
        elif action == "enable":
            systemctl_user("enable", unit)
        elif action == "disable":
            systemctl_user("disable", unit)

    def apply_settings_action(self, action: str, scope: str):
        if action in (None, "none"):
            return
        if action == "edit":
            self.stack.set_visible_child_name("apps")
            return
        if action == "reset":
            if scope == "tracking":
                self.cfg["tracking_cmd"] = DEFAULTS["tracking_cmd"]
                self.cfg["tracking_ready"] = DEFAULTS["tracking_ready"]
                self.entry_tracking_cmd.set_text(self.cfg["tracking_cmd"])
                self.entry_tracking_ready.set_text(self.cfg["tracking_ready"])
            elif scope == "server":
                self.cfg["server_cmd"] = DEFAULTS["server_cmd"]
                self.cfg["server_pgrep"] = DEFAULTS["server_pgrep"]
                self.entry_server_cmd.set_text(self.cfg["server_cmd"])
                self.entry_server_pgrep.set_text(self.cfg["server_pgrep"])
            elif scope == "vr":
                self.cfg["vr_cmd"] = DEFAULTS["vr_cmd"]
                self.cfg["vr_pgrep"] = DEFAULTS["vr_pgrep"]
                self.entry_vr_cmd.set_text(self.cfg["vr_cmd"])
                self.entry_vr_pgrep.set_text(self.cfg["vr_pgrep"])
            elif scope == "patterns":
                self.cfg["tracking_ready"] = DEFAULTS["tracking_ready"]
                self.cfg["server_pgrep"] = DEFAULTS["server_pgrep"]
                self.cfg["vr_pgrep"] = DEFAULTS["vr_pgrep"]
                self.entry_tracking_ready.set_text(self.cfg["tracking_ready"])
                self.entry_server_pgrep.set_text(self.cfg["server_pgrep"])
                self.entry_vr_pgrep.set_text(self.cfg["vr_pgrep"])
            cfg_save(self.cfg)

    # ---------------- Profiles ----------------
    def build_profiles_view(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)

        box.pack_start(self.section_header("Profiles"), False, False, 0)

        top = Gtk.Box(spacing=10)
        box.pack_start(top, False, False, 0)

        self.combo_profile = Gtk.ComboBoxText()
        self.refresh_profiles_combo()
        self._combo_set(self.combo_profile, self.cfg.get("profile", "default"))

        self.combo_profile.connect("changed", lambda *_: None)

        btn_select = Gtk.Button(label="Set as active")
        btn_select.set_image(Gtk.Image.new_from_icon_name("emblem-ok", Gtk.IconSize.BUTTON))
        btn_select.set_always_show_image(True)
        btn_select.connect("clicked", lambda *_: self.on_set_profile())

        top.pack_start(Gtk.Label(label="Profile:", xalign=0), False, False, 0)
        top.pack_start(self.combo_profile, False, False, 0)
        top.pack_start(btn_select, False, False, 0)

        # list + actions
        self.profile_list = Gtk.ListBox()
        self.profile_list.set_selection_mode(Gtk.SelectionMode.SINGLE)
        box.pack_start(self.profile_list, True, True, 0)

        btns = Gtk.Box(spacing=10)
        box.pack_start(btns, False, False, 0)

        btn_new = Gtk.Button(label="New")
        btn_new.set_image(Gtk.Image.new_from_icon_name("list-add", Gtk.IconSize.BUTTON))
        btn_new.set_always_show_image(True)
        btn_new.connect("clicked", lambda *_: self.on_new_profile())

        btn_rename = Gtk.Button(label="Rename")
        btn_rename.set_image(Gtk.Image.new_from_icon_name("edit-rename", Gtk.IconSize.BUTTON))
        btn_rename.set_always_show_image(True)
        btn_rename.connect("clicked", lambda *_: self.on_rename_profile())

        btn_delete = Gtk.Button(label="Delete")
        btn_delete.set_image(Gtk.Image.new_from_icon_name("edit-delete", Gtk.IconSize.BUTTON))
        btn_delete.set_always_show_image(True)
        btn_delete.connect("clicked", lambda *_: self.on_delete_profile())

        btn_edit = Gtk.Button(label="Edit")
        btn_edit.set_image(Gtk.Image.new_from_icon_name("document-edit", Gtk.IconSize.BUTTON))
        btn_edit.set_always_show_image(True)
        btn_edit.connect("clicked", lambda *_: self.on_edit_profile())

        btns.pack_start(btn_new, False, False, 0)
        btns.pack_start(btn_edit, False, False, 0)
        btns.pack_start(btn_rename, False, False, 0)
        btns.pack_start(btn_delete, False, False, 0)

        help_block = Gtk.Label(xalign=0)
        help_block.set_line_wrap(True)
        help_block.set_text(
            "Profiles let you save different app commands/patterns for different setups (e.g. VR streaming server vs something else). "
            "This GUI stores profiles as simple .conf files under ~/.config/vr-stack/profiles/."
        )
        box.pack_start(help_block, False, False, 0)

        self.refresh_profiles_list()
        return self.wrap_scroller(box)

    def profiles(self):
        files = sorted(PROFILES_DIR.glob("*.conf"))
        out = []
        for f in files:
            out.append((f.stem, f))
        # ensure default exists
        default_path = PROFILES_DIR / "default.conf"
        if not default_path.exists():
            write_kv(default_path, DEFAULTS.copy())
        if ("default", default_path) not in out:
            out.insert(0, ("default", default_path))
        return out

    def refresh_profiles_combo(self):
        self.combo_profile.remove_all()
        for name, _ in self.profiles():
            self.combo_profile.append(name, name)

    def refresh_profiles_list(self):
        for row in list(self.profile_list.get_children()):
            self.profile_list.remove(row)
        for name, path in self.profiles():
            row = Gtk.ListBoxRow()
            h = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            row.add(h)
            lbl = Gtk.Label(label=name, xalign=0)
            sub = Gtk.Label(label=str(path), xalign=0)
            sub.get_style_context().add_class("dim-label")
            v = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
            v.pack_start(lbl, False, False, 0)
            v.pack_start(sub, False, False, 0)
            h.pack_start(v, True, True, 0)
            row.profile_name = name
            row.profile_path = path
            self.profile_list.add(row)
        self.profile_list.show_all()

    def selected_profile_row(self):
        return self.profile_list.get_selected_row()

    def on_set_profile(self):
        name = self.combo_profile.get_active_id() or "default"
        self.cfg["profile"] = name
        cfg_save(self.cfg)
        self.refresh_status()
        info_dialog(self, "Profile set", f"Active profile set to: {name}\n\nNote: your start script/service must load and apply the profile file for this to affect launches.")

    def ask_text(self, title, prompt, initial=""):
        d = Gtk.Dialog(title, self, 0, ("Cancel", Gtk.ResponseType.CANCEL, "OK", Gtk.ResponseType.OK))
        box = d.get_content_area()
        box.set_spacing(8)
        box.pack_start(Gtk.Label(label=prompt, xalign=0), False, False, 0)
        entry = Gtk.Entry()
        entry.set_text(initial)
        box.pack_start(entry, False, False, 0)
        d.show_all()
        rc = d.run()
        txt = entry.get_text().strip()
        d.destroy()
        if rc == Gtk.ResponseType.OK and txt:
            return txt
        return None

    def on_new_profile(self):
        name = self.ask_text("New profile", "Profile name (letters/numbers/dash):")
        if not name:
            return
        path = PROFILES_DIR / f"{name}.conf"
        if path.exists():
            info_dialog(self, "Exists", "That profile already exists.")
            return
        write_kv(path, DEFAULTS.copy())
        self.refresh_profiles_combo()
        self.refresh_profiles_list()
        self._combo_set(self.combo_profile, name)
        info_dialog(self, "Created", f"Created {path}")

    def on_rename_profile(self):
        row = self.selected_profile_row()
        if not row:
            info_dialog(self, "No selection", "Select a profile first.")
            return
        if row.profile_name == "default":
            info_dialog(self, "Not allowed", "You can't rename the default profile.")
            return
        newname = self.ask_text("Rename profile", "New name:", row.profile_name)
        if not newname:
            return
        newpath = PROFILES_DIR / f"{newname}.conf"
        if newpath.exists():
            info_dialog(self, "Exists", "A profile with that name already exists.")
            return
        row.profile_path.rename(newpath)
        # update active profile if needed
        if self.cfg.get("profile") == row.profile_name:
            self.cfg["profile"] = newname
            cfg_save(self.cfg)
        self.refresh_profiles_combo()
        self.refresh_profiles_list()
        self._combo_set(self.combo_profile, self.cfg.get("profile", "default"))

    def on_delete_profile(self):
        row = self.selected_profile_row()
        if not row:
            info_dialog(self, "No selection", "Select a profile first.")
            return
        if row.profile_name == "default":
            info_dialog(self, "Not allowed", "You can't delete the default profile.")
            return
        if not confirm_dialog(self, "Delete profile?", f"Delete {row.profile_name} ?\n{row.profile_path}"):
            return
        try:
            row.profile_path.unlink()
        except Exception as e:
            info_dialog(self, "Error", str(e))
        if self.cfg.get("profile") == row.profile_name:
            self.cfg["profile"] = "default"
            cfg_save(self.cfg)
        self.refresh_profiles_combo()
        self.refresh_profiles_list()
        self._combo_set(self.combo_profile, self.cfg.get("profile", "default"))
        self.refresh_status()

    def on_edit_profile(self):
        row = self.selected_profile_row()
        if not row:
            info_dialog(self, "No selection", "Select a profile first.")
            return
        # Use editor if set, else xdg-open
        editor = os.environ.get("EDITOR")
        if editor:
            subprocess.Popen([editor, str(row.profile_path)])
        else:
            subprocess.Popen(["xdg-open", str(row.profile_path)])

    # ---------------- Debug ----------------
    def build_debug_view(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.pack_start(self.section_header("Debug"), False, False, 0)

        self.txt_debug = Gtk.TextView()
        self.txt_debug.set_editable(False)
        self.txt_debug.set_monospace(True)

        btn_row = Gtk.Box(spacing=10)
        btn_refresh = Gtk.Button(label="Refresh")
        btn_refresh.set_image(Gtk.Image.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON))
        btn_refresh.set_always_show_image(True)
        btn_refresh.connect("clicked", lambda *_: self.refresh_debug())
        btn_row.pack_start(btn_refresh, False, False, 0)

        box.pack_start(btn_row, False, False, 0)
        box.pack_start(self.wrap_scroller(self.txt_debug), True, True, 0)

        self.refresh_debug()
        return box

    def refresh_debug(self):
        lines = []
        lines.append(f"Version: {APP_VERSION}")
        lines.append(f"Config: {STACK_CONF}")
        lines.append(f"Profiles: {PROFILES_DIR}")
        lines.append(f"GUI state: {GUI_STATE}")
        lines.append("")
        lines.append("systemctl --user status vr-stack-control.service")
        rc, out = systemctl_user("status", "vr-stack-control.service", "--no-pager", "-l")
        lines.append(out)
        lines.append("")

        buf = self.txt_debug.get_buffer()
        buf.set_text("\n".join(lines))

    # ---------------- helpers ----------------
    def section_header(self, text):
        lbl = Gtk.Label()
        lbl.set_markup(f"<span size='x-large' weight='bold'>{GLib.markup_escape_text(text)}</span>")
        lbl.set_xalign(0)
        return lbl

    def small_muted(self, text):
        # Small, muted left-aligned label (for table headings / hints)
        safe = GLib.markup_escape_text(str(text))
        lbl = Gtk.Label()
        lbl.set_xalign(0)
        lbl.set_use_markup(True)
        lbl.set_markup(f"<span size='small' alpha='700'>{safe}</span>")
        return lbl

    def value_label(self, text, monospace=False):
        lbl = Gtk.Label(label=str(text))
        lbl.set_xalign(0)
        lbl.set_yalign(0.5)
        lbl.set_selectable(True)
        lbl.set_hexpand(True)
        lbl.set_line_wrap(True)
        lbl.set_max_width_chars(80)
        if monospace:
            try:
                lbl.get_style_context().add_class("monospace")
            except Exception:
                pass
        return lbl


    def wrap_scroller(self, child):
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        sw.add(child)
        return sw

    def _grid_row(self, grid, row, label, widget):
        l = Gtk.Label(label=label, xalign=0)
        grid.attach(l, 0, row, 1, 1)
        grid.attach(widget, 1, row, 1, 1)

    def _grid_row_switch(self, grid, row, label, sw, why):
        l = Gtk.Label(label=label, xalign=0)
        grid.attach(l, 0, row, 1, 1)
        grid.attach(sw, 1, row, 1, 1)
        w = Gtk.Label(label=why, xalign=0)
        w.set_line_wrap(True)
        w.get_style_context().add_class("dim-label")
        grid.attach(w, 2, row, 1, 1)
        return row + 1

    def _grid_row_combo(self, grid, row, label, combo, why):
        l = Gtk.Label(label=label, xalign=0)
        grid.attach(l, 0, row, 1, 1)
        grid.attach(combo, 1, row, 1, 1)
        w = Gtk.Label(label=why, xalign=0)
        w.set_line_wrap(True)
        w.get_style_context().add_class("dim-label")
        grid.attach(w, 2, row, 1, 1)
        return row + 1

    def _grid_entry(self, grid, row, label, entry, why):
        l = Gtk.Label(label=label, xalign=0)
        grid.attach(l, 0, row, 1, 1)
        grid.attach(entry, 1, row, 1, 1)
        w = Gtk.Label(label=why, xalign=0)
        w.set_line_wrap(True)
        w.get_style_context().add_class("dim-label")
        grid.attach(w, 2, row, 1, 1)
        return row + 1


    def _make_ro(self, entry: Gtk.Entry):
        entry.set_editable(False)
        entry.set_can_focus(True)

    def _status_for_path(self, p: str, want: str) -> str:
        # want: "file" or "dir"
        if not p:
            return "‚ö†"
        try:
            pp = Path(p).expanduser()
            # Show warning for dangling symlink (common when Steam paths are linked to ~/.config/openvr then deleted)
            if pp.is_symlink() and not pp.exists():
                return "‚ö†"
            if want == "dir":
                return "‚úî" if pp.is_dir() else "‚ùå"
            return "‚úî" if pp.is_file() else "‚ùå"
        except Exception:
            return "‚ùå"

    def save_config(self):
        cfg_save(self.cfg)

    def _bind_entry_override(self, entry: Gtk.Entry, cfg_key: str):
        # Let users type overrides directly (in addition to Browse‚Ä¶)
        try:
            entry.set_placeholder_text("Leave blank to auto-detect")
        except Exception:
            pass

        def _commit(*_args):
            try:
                val = (entry.get_text() or "").strip()
                if val:
                    self.cfg[cfg_key] = val
                else:
                    if cfg_key in self.cfg:
                        del self.cfg[cfg_key]
                self.save_config()
                self.update_detected_paths()
            except Exception as e:
                self.debug_log(f"Failed to save override {cfg_key}: {e}")
            return False

        entry.connect("activate", _commit)
        entry.connect("focus-out-event", _commit)
    def repair_openvrpaths(self):
        """Recreate ~/.config/openvr/openvrpaths.vrpath and point Steam to it.

        This is intentionally safe:
        - Never deletes user data (backs up existing real files).
        - If no existing openvrpaths.vrpath can be found, it will try to *generate* a minimal one
          using detected SteamVR install paths.
        """
        try:
            home = Path.home()
            canonical = home / ".config" / "openvr" / "openvrpaths.vrpath"
            canonical.parent.mkdir(parents=True, exist_ok=True)

            steam_paths = [
                home / ".steam" / "steam" / "config" / "openvrpaths.vrpath",
                home / ".local" / "share" / "Steam" / "config" / "openvrpaths.vrpath",
                home / ".steam" / "root" / "config" / "openvrpaths.vrpath",
            ]

            def _is_real_file(p: Path) -> bool:
                try:
                    return p.exists() and p.is_file() and (not p.is_symlink())
                except Exception:
                    return False

            # 1) If canonical is missing, try to copy from any existing real file.
            if not canonical.exists():
                src = None
                for sp in steam_paths:
                    if _is_real_file(sp):
                        src = sp
                        break

                # 2) If we only have symlinks, try following them to a real file.
                if not src:
                    for sp in steam_paths:
                        try:
                            if sp.is_symlink():
                                tgt = sp.resolve(strict=False)
                                if tgt.exists() and tgt.is_file():
                                    src = tgt
                                    break
                        except Exception:
                            pass

                if src:
                    try:
                        canonical.write_bytes(src.read_bytes())
                    except Exception:
                        import shutil as _sh
                        _sh.copy2(str(src), str(canonical))

            # 3) Still missing? Generate a minimal openvrpaths.vrpath from detected SteamVR paths.
            if not canonical.exists():
                import json

                steamvr_root = (self.cfg.get("override_steamvr_root") or "").strip()
                if not steamvr_root:
                    # Derive from SteamVR OpenXR JSON if we can
                    sj = (self.cfg.get("override_steamvr_openxr_json") or self.find_steamvr_openxr_json() or "").strip()
                    if sj:
                        try:
                            steamvr_root = str(Path(sj).expanduser().parent)
                        except Exception:
                            steamvr_root = ""

                root = Path(steamvr_root).expanduser() if steamvr_root else None
                if root and root.is_file():
                    root = root.parent

                steam_base = None
                if root:
                    # Try to find a parent that looks like a Steam install root (has steamapps/ and config/)
                    for parent in [root] + list(root.parents):
                        try:
                            if (parent / "steamapps").is_dir() and (parent / "config").is_dir():
                                steam_base = parent
                                break
                        except Exception:
                            pass

                # Fallback candidates
                if steam_base is None:
                    for cand in (
                        home / ".steam" / "steam",
                        home / ".local" / "share" / "Steam",
                        home / ".steam" / "root",
                    ):
                        try:
                            if (cand / "config").is_dir() or (cand / "steamapps").is_dir():
                                steam_base = cand
                                break
                        except Exception:
                            pass

                if steam_base is not None and root is not None:
                    cfg_dir = steam_base / "config"
                    log_dir = steam_base / "logs"
                    cfg_dir.mkdir(parents=True, exist_ok=True)
                    log_dir.mkdir(parents=True, exist_ok=True)

                    data = {
                        "config": [str(cfg_dir)],
                        "external_drivers": [],
                        "jsonid": "vrpathreg",
                        "log": [str(log_dir)],
                        "runtime": [str(root)],
                        "version": 1,
                    }
                    canonical.write_text(json.dumps(data, indent=2) + "\\n")
            if not canonical.exists():
                self.toast("openvrpaths.vrpath not found. Set SteamVR OpenVR root, or start SteamVR once, then click Repair again.")
                return

            # Set override to canonical so the UI reflects the canonical path.
            self.cfg["override_openvrpaths"] = str(canonical)
            self.save_config()

            # Update Steam locations to symlink to canonical.
            ts = time.strftime("%Y%m%d-%H%M%S")
            for sp in steam_paths:
                try:
                    sp.parent.mkdir(parents=True, exist_ok=True)
                    if sp.is_symlink():
                        try:
                            sp.unlink()
                        except Exception:
                            pass
                    elif sp.exists():
                        backup = sp.with_suffix(sp.suffix + f".bak.{ts}")
                        try:
                            sp.rename(backup)
                        except Exception:
                            pass
                    if sp.exists() or sp.is_symlink():
                        try:
                            sp.unlink()
                        except Exception:
                            pass
                    sp.symlink_to(canonical)
                except Exception as e:
                    self.debug_log(f"repair_openvrpaths: failed for {sp}: {e}")

            self.toast("Repaired openvrpaths.vrpath (canonical created + symlinks updated).")
            self.update_detected_paths()
        except Exception as e:
            self.toast(f"Repair failed: {e}")

    def _browse_override(self, kind: str, cfg_key: str):
        # kind: "file" or "dir"
        action = Gtk.FileChooserAction.OPEN if kind == "file" else Gtk.FileChooserAction.SELECT_FOLDER
        dlg = Gtk.FileChooserDialog(
            title="Select " + ("file" if kind == "file" else "folder"),
            parent=self,
            action=action
        )
        dlg.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OPEN, Gtk.ResponseType.OK)
        resp = dlg.run()
        if resp == Gtk.ResponseType.OK:
            chosen = dlg.get_filename()
            if chosen:
                self.cfg[cfg_key] = chosen
                self.save_config()
                self.update_detected_paths()
        dlg.destroy()

    def _grid_path(self, grid, row, label, entry, status_label, browse_tuple, why):
        l = Gtk.Label(label=label, xalign=0)
        grid.attach(l, 0, row, 1, 1)
        grid.attach(entry, 1, row, 1, 1)
        grid.attach(status_label, 2, row, 1, 1)
        if browse_tuple:
            kind, key = browse_tuple
            b = Gtk.Button(label="Browse‚Ä¶")
            b.connect("clicked", lambda *_: self._browse_override(kind, key))
            grid.attach(b, 3, row, 1, 1)
        w = Gtk.Label(label=why, xalign=0)
        w.set_line_wrap(True)
        w.get_style_context().add_class("dim-label")
        grid.attach(w, 4, row, 1, 1)
        return row + 1

    def _combo_set(self, combo: Gtk.ComboBoxText, key: str):
        try:
            combo.set_active_id(key)
        except Exception:
            combo.set_active(0)


def main():
    win = VRControlApp()
    win.connect("destroy", Gtk.main_quit)
    Gtk.main()


if __name__ == "__main__":
    main()
